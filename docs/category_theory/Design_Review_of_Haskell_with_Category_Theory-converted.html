<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>092d887d-ca62-4ad9-90f2-8cd65bc7b70a</title><style type="text/css"> * {margin:0; padding:0; text-indent:0; }
 .s1 { color: black; font-family:Garamond, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 17pt; }
 .s2 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s3 { color: black; font-family:"Lucida Sans Unicode", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; vertical-align: 4pt; }
 .s4 { color: black; font-family:"Lucida Sans Unicode", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 h1 { color: black; font-family:"Book Antiqua", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 14pt; }
 .h3, h3 { color: black; font-family:Georgia, serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10pt; }
 .s5 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .p, p { color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; margin:0pt; }
 .s6 { color: #00F; font-family:Cambria, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s7 { color: black; font-family:Cambria, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6pt; vertical-align: 3pt; }
 .s8 { color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s9 { color: black; font-family:"Bookman Old Style", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 10pt; }
 h2 { color: black; font-family:"Book Antiqua", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 .s10 { color: black; font-family:"Lucida Sans Unicode", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s11 { color: black; font-family:Garamond, serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 6.5pt; vertical-align: -1pt; }
 .s12 { color: black; font-family:"Bookman Old Style", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 6.5pt; vertical-align: -1pt; }
 .s13 { color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 15pt; }
 .s16 { color: black; font-family:Cambria, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s17 { color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6.5pt; vertical-align: -1pt; }
 .s18 { color: black; font-family:"Bookman Old Style", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: -2pt; }
 .s19 { color: black; font-family:"Bookman Old Style", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 7pt; vertical-align: 4pt; }
 .s20 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s21 { color: black; font-family:"Microsoft PhagsPa", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s22 { color: black; font-family:"Bookman Old Style", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 7pt; }
 .s23 { color: black; font-family:"Microsoft PhagsPa", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: 3pt; }
 .s24 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 7pt; }
 .s25 { color: black; font-family:"Bookman Old Style", serif; font-style: italic; font-weight: normal; text-decoration: underline; font-size: 7pt; }
 .s26 { color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 7pt; }
 .s27 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: 3pt; }
 .s28 { color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: 2pt; }
 .s29 { color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7pt; }
 .s30 { color: black; font-family:"Lucida Sans Unicode", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: 2pt; }
 .s31 { color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: 2pt; }
 .s32 { color: #7F7F7F; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 5pt; }
 .s33 { color: black; font-family:"Microsoft PhagsPa", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: 2pt; }
 .s34 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: 2pt; }
 .s35 { color: black; font-family:"Bookman Old Style", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 4.5pt; vertical-align: -1pt; }
 .s36 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 7pt; vertical-align: 7pt; }
 .s37 { color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 7pt; vertical-align: 7pt; }
 .s38 { color: black; font-family:"Bookman Old Style", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 7pt; vertical-align: 1pt; }
 .s39 { color: black; font-family:"Bookman Old Style", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 5pt; }
 .s40 { color: black; font-family:Garamond, serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s41 { color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6.5pt; vertical-align: 3pt; }
 .s42 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 7pt; vertical-align: 8pt; }
 .s43 { color: black; font-family:"Bookman Old Style", serif; font-style: italic; font-weight: normal; text-decoration: underline; font-size: 7pt; vertical-align: 8pt; }
 .s44 { color: black; font-family:"Bookman Old Style", serif; font-style: italic; font-weight: normal; text-decoration: underline; font-size: 5pt; vertical-align: 6pt; }
 .s45 { color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 5pt; vertical-align: 6pt; }
 .s46 { color: black; font-family:"Bookman Old Style", serif; font-style: italic; font-weight: normal; text-decoration: underline; font-size: 5pt; vertical-align: 6pt; }
 .s47 { color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7pt; vertical-align: 1pt; }
 .s48 { color: black; font-family:"Bookman Old Style", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 5pt; }
 .s49 { color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 5pt; }
 .s50 { color: black; font-family:"Bookman Old Style", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 7pt; vertical-align: 7pt; }
 .s51 { color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7pt; vertical-align: 7pt; }
 .s52 { color: black; font-family:"Bookman Old Style", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 5pt; vertical-align: 6pt; }
 .s53 { color: black; font-family:"Bookman Old Style", serif; font-style: italic; font-weight: normal; text-decoration: underline; font-size: 7pt; vertical-align: 7pt; }
 .s54 { color: black; font-family:"Bookman Old Style", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 7pt; vertical-align: -3pt; }
 .s55 { color: black; font-family:"Bookman Old Style", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 5pt; vertical-align: -4pt; }
 .s56 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: -3pt; }
 .s57 { color: black; font-family:"Microsoft PhagsPa", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: -3pt; }
 .s58 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 7pt; vertical-align: -4pt; }
 .s59 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7pt; vertical-align: -4pt; }
 .s60 { color: black; font-family:Garamond, serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 7pt; }
 .s61 { color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: -5pt; }
 li {display: block; }
 #l1 {padding-left: 0pt;counter-reset: c1 1; }
 #l1> li>*:first-child:before {counter-increment: c1; content: counter(c1, decimal)" "; color: black; font-family:Georgia, serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10pt; }
 #l1> li:first-child>*:first-child:before {counter-increment: c1 0;  }
 #l2 {padding-left: 0pt;counter-reset: c2 1; }
 #l2> li>*:first-child:before {counter-increment: c2; content: counter(c1, decimal)"."counter(c2, decimal)" "; color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l2> li:first-child>*:first-child:before {counter-increment: c2 0;  }
 #l3 {padding-left: 0pt;counter-reset: c2 1; }
 #l3> li>*:first-child:before {counter-increment: c2; content: counter(c1, decimal)"."counter(c2, decimal)" "; color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l3> li:first-child>*:first-child:before {counter-increment: c2 0;  }
 #l4 {padding-left: 0pt;counter-reset: c3 1; }
 #l4> li>*:first-child:before {counter-increment: c3; content: counter(c1, decimal)"."counter(c2, decimal)"."counter(c3, decimal)" "; color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l4> li:first-child>*:first-child:before {counter-increment: c3 0;  }
 #l5 {padding-left: 0pt;counter-reset: c3 1; }
 #l5> li>*:first-child:before {counter-increment: c3; content: counter(c1, decimal)"."counter(c2, decimal)"."counter(c3, decimal)" "; color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l5> li:first-child>*:first-child:before {counter-increment: c3 0;  }
 #l6 {padding-left: 0pt;counter-reset: c3 1; }
 #l6> li>*:first-child:before {counter-increment: c3; content: counter(c1, decimal)"."counter(c2, decimal)"."counter(c3, decimal)" "; color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l6> li:first-child>*:first-child:before {counter-increment: c3 0;  }
 #l7 {padding-left: 0pt;counter-reset: c2 1; }
 #l7> li>*:first-child:before {counter-increment: c2; content: counter(c1, decimal)"."counter(c2, decimal)" "; color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l7> li:first-child>*:first-child:before {counter-increment: c2 0;  }
 #l8 {padding-left: 0pt;counter-reset: c3 1; }
 #l8> li>*:first-child:before {counter-increment: c3; content: counter(c1, decimal)"."counter(c2, decimal)"."counter(c3, decimal)" "; color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l8> li:first-child>*:first-child:before {counter-increment: c3 0;  }
 li {display: block; }
 #l9 {padding-left: 0pt;counter-reset: d1 1; }
 #l9> li>*:first-child:before {counter-increment: d1; content: counter(d1, decimal)" "; color: black; font-family:"Book Antiqua", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 14pt; }
 #l9> li:first-child>*:first-child:before {counter-increment: d1 0;  }
 #l10 {padding-left: 0pt;counter-reset: d2 1; }
 #l10> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:"Book Antiqua", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 #l10> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l11 {padding-left: 0pt;counter-reset: e1 1; }
 #l11> li>*:first-child:before {counter-increment: e1; content: counter(e1, decimal)". "; color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l11> li:first-child>*:first-child:before {counter-increment: e1 0;  }
 #l12 {padding-left: 0pt;counter-reset: d2 1; }
 #l12> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:"Book Antiqua", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 #l12> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l13 {padding-left: 0pt;counter-reset: d3 1; }
 #l13> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Georgia, serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10pt; }
 #l13> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l14 {padding-left: 0pt;counter-reset: d4 1; }
 #l14> li>*:first-child:before {counter-increment: d4; content: counter(d4, decimal)". "; color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l14> li:first-child>*:first-child:before {counter-increment: d4 0;  }
 #l15 {padding-left: 0pt; }
 #l15> li>*:first-child:before {content: "• "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l16 {padding-left: 0pt; }
 #l16> li>*:first-child:before {content: "• "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l17 {padding-left: 0pt; }
 #l17> li>*:first-child:before {content: "• "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l18 {padding-left: 0pt; }
 #l18> li>*:first-child:before {content: "• "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l19 {padding-left: 0pt; }
 #l19> li>*:first-child:before {content: "• "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l20 {padding-left: 0pt;counter-reset: d3 1; }
 #l20> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Georgia, serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10pt; }
 #l20> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l21 {padding-left: 0pt;counter-reset: j1 1; }
 #l21> li>*:first-child:before {counter-increment: j1; content: counter(j1, decimal)" "; color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l21> li:first-child>*:first-child:before {counter-increment: j1 0;  }
 #l22 {padding-left: 0pt; }
 #l22> li>*:first-child:before {content: "• "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l23 {padding-left: 0pt; }
 #l23> li>*:first-child:before {content: "• "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l24 {padding-left: 0pt; }
 #l24> li>*:first-child:before {content: "• "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l25 {padding-left: 0pt; }
 #l25> li>*:first-child:before {content: "• "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l26 {padding-left: 0pt; }
 #l26> li>*:first-child:before {content: "• "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l27 {padding-left: 0pt;counter-reset: d3 1; }
 #l27> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Georgia, serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10pt; }
 #l27> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l28 {padding-left: 0pt; }
 #l28> li>*:first-child:before {content: "• "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l29 {padding-left: 0pt; }
 #l29> li>*:first-child:before {content: "• "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l30 {padding-left: 0pt;counter-reset: d2 1; }
 #l30> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:"Book Antiqua", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 #l30> li:first-child>*:first-child:before {counter-increment: d2 0;  }
 #l31 {padding-left: 0pt;counter-reset: d3 1; }
 #l31> li>*:first-child:before {counter-increment: d3; content: counter(d1, decimal)"."counter(d2, decimal)"."counter(d3, decimal)" "; color: black; font-family:Georgia, serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10pt; }
 #l31> li:first-child>*:first-child:before {counter-increment: d3 0;  }
 #l32 {padding-left: 0pt;counter-reset: r1 1; }
 #l32> li>*:first-child:before {counter-increment: r1; content: counter(r1, decimal)" "; color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l32> li:first-child>*:first-child:before {counter-increment: r1 0;  }
 #l33 {padding-left: 0pt; }
 #l33> li>*:first-child:before {content: "• "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l34 {padding-left: 0pt; }
 #l34> li>*:first-child:before {content: "• "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l35 {padding-left: 0pt; }
 #l35> li>*:first-child:before {content: "• "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l36 {padding-left: 0pt;counter-reset: s1 1; }
 #l36> li>*:first-child:before {counter-increment: s1; content: counter(s1, decimal)" "; color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l36> li:first-child>*:first-child:before {counter-increment: s1 0;  }
 #l37 {padding-left: 0pt; }
 #l37> li>*:first-child:before {content: "• "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l38 {padding-left: 0pt; }
 #l38> li>*:first-child:before {content: "• "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l39 {padding-left: 0pt;counter-reset: v1 1; }
 #l39> li>*:first-child:before {counter-increment: v1; content: counter(v1, decimal)" "; color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l39> li:first-child>*:first-child:before {counter-increment: v1 0;  }
 li {display: block; }
 #l40 {padding-left: 0pt;counter-reset: w1 1; }
 #l40> li>*:first-child:before {counter-increment: w1; content: "["counter(w1, decimal)"] "; color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l40> li:first-child>*:first-child:before {counter-increment: w1 0;  }
</style></head><body><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 88pt;text-indent: 0pt;line-height: 114%;text-align: center;">Design Review of Haskell’s Functional Programming Language</p><p class="s2" style="padding-top: 10pt;padding-left: 161pt;text-indent: 3pt;line-height: 85%;text-align: center;">Ike Uchenna Chukwu<span class="s3">∗</span><span class="s4"> </span>Washington, DC, USA</p><p class="s2" style="padding-top: 9pt;text-indent: 0pt;text-align: center;">August 26, 2024</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h1 style="padding-left: 47pt;text-indent: 0pt;text-align: left;">Contents</h1><ol id="l1"><li data-list-text="1"><h3 style="padding-top: 9pt;padding-left: 62pt;text-indent: -14pt;text-align: left;">Introduction<span class="s5">                                </span>4</h3><ol id="l2"><li data-list-text="1.1"><p style="padding-left: 85pt;text-indent: -22pt;text-align: left;">Background<span class="s5">                               </span>4</p></li><li data-list-text="1.2"><p style="padding-left: 85pt;text-indent: -22pt;text-align: left;">Motivation<span class="s5">                               </span>4</p></li><li data-list-text="1.3"><p style="padding-left: 85pt;text-indent: -22pt;text-align: left;">Objectives<span class="s5">                                </span>5</p></li></ol></li><li data-list-text="2"><h3 style="padding-top: 10pt;padding-left: 62pt;text-indent: -14pt;text-align: left;">Basic Concepts of Category Theory<span class="s5">                 </span>6</h3><ol id="l3"><li data-list-text="2.1"><p style="padding-left: 85pt;text-indent: -22pt;text-align: left;">Categories<span class="s5">                                </span>6</p><ol id="l4"><li data-list-text="2.1.1"><p style="padding-left: 117pt;text-indent: -31pt;text-align: left;">Definition<span class="s5">                            </span>6</p></li><li data-list-text="2.1.2"><p style="padding-left: 117pt;text-indent: -31pt;text-align: left;">Example of a Category: The Category of Sets<span class="s5">       </span>7</p></li><li data-list-text="2.1.3"><p style="padding-left: 117pt;text-indent: -31pt;text-align: left;">Visualization<span class="s5">                          </span>7</p></li><li data-list-text="2.1.4"><p style="padding-left: 117pt;text-indent: -31pt;text-align: left;">Axioms and Properties<span class="s5">                    </span>7</p></li><li data-list-text="2.1.5"><p style="padding-left: 117pt;text-indent: -31pt;text-align: left;">Categories in Haskell<span class="s5">                     </span>8</p></li></ol></li><li data-list-text="2.2"><p style="padding-left: 85pt;text-indent: -22pt;text-align: left;">Functors<span class="s5">                                 </span>8</p><ol id="l5"><li data-list-text="2.2.1"><p style="padding-left: 117pt;text-indent: -31pt;text-align: left;">Definition of a Functor<span class="s5">                    </span>8</p></li><li data-list-text="2.2.2"><p style="padding-left: 117pt;text-indent: -31pt;text-align: left;">Example: Functor in the Category of Sets<span class="s5">        </span>9</p></li><li data-list-text="2.2.3"><p style="padding-left: 117pt;text-indent: -31pt;text-align: left;">Visualization<span class="s5">                          </span>9</p></li><li data-list-text="2.2.4"><p style="padding-left: 117pt;text-indent: -31pt;text-align: left;">Functors in Haskell<span class="s5">                     </span>10</p></li><li data-list-text="2.2.5"><p style="padding-left: 117pt;text-indent: -31pt;text-align: left;">Example: <span class="s6">Maybe </span>Functor in Haskell<span class="s5">           </span>11</p></li></ol></li><li data-list-text="2.3"><p style="padding-left: 85pt;text-indent: -22pt;text-align: left;">Natural Transformations<span class="s5">                      </span>11</p><ol id="l6"><li data-list-text="2.3.1"><p style="padding-left: 117pt;text-indent: -31pt;text-align: left;">Definition of a Natural Transformation<span class="s5">         </span>11</p></li><li data-list-text="2.3.2"><p style="padding-left: 117pt;text-indent: -31pt;text-align: left;">Intuition Behind Natural Transformations<span class="s5">       </span>12</p></li><li data-list-text="2.3.3"><p style="padding-left: 117pt;text-indent: -31pt;text-align: left;">Example: Natural Transformation Between Functors on</p><h3 style="padding-left: 117pt;text-indent: 0pt;text-align: left;">Set<span class="s5">                               </span><span class="p">12</span></h3></li><li data-list-text="2.3.4"><p style="padding-left: 117pt;text-indent: -31pt;text-align: left;">Natural Transformations in Haskell<span class="s5">            </span>12</p></li><li data-list-text="2.3.5"><p style="padding-left: 117pt;text-indent: -31pt;text-align: left;">Example: Maybe to List Natural Transformation<span class="s5">     </span>12</p></li><li data-list-text="2.3.6"><p style="padding-left: 117pt;text-indent: -31pt;text-align: left;">Visualizing the Example<span class="s5">                  </span>13</p><p style="text-indent: 0pt;text-align: left;"/><p class="s7" style="padding-top: 6pt;padding-left: 47pt;text-indent: 11pt;text-align: left;">∗<span class="s8">Author’s Note: Portions of this manuscript were generated with the assistance of Chat- GPT.</span></p></li><li data-list-text="2.3.7"><p style="padding-top: 34pt;padding-left: 117pt;text-indent: -31pt;text-align: left;">Summary<span class="s5">                           </span>13</p></li></ol></li></ol></li><li data-list-text="3"><h3 style="padding-top: 10pt;padding-left: 62pt;text-indent: -14pt;text-align: left;">Advanced Concept: Monads<span class="s5">                     </span>13</h3><ol id="l7"><li data-list-text="3.1"><p style="padding-left: 85pt;text-indent: -22pt;text-align: left;">Monads<span class="s5">                                </span>13</p><ol id="l8"><li data-list-text="3.1.1"><p style="padding-left: 117pt;text-indent: -31pt;text-align: left;">Definition of a Monad<span class="s5">                   </span>13</p></li><li data-list-text="3.1.2"><p style="padding-left: 117pt;text-indent: -31pt;text-align: left;">Monads in Haskell<span class="s5">                      </span>15</p></li><li data-list-text="3.1.3"><p style="padding-left: 117pt;text-indent: -31pt;text-align: left;">Example: The <span class="s6">Maybe </span>Monad<span class="s5">                </span>15</p></li><li data-list-text="3.1.4"><p style="padding-left: 117pt;text-indent: -31pt;text-align: left;">Visualizing the Monad Laws<span class="s5">               </span>16</p></li><li data-list-text="3.1.5"><p style="padding-left: 117pt;text-indent: -31pt;text-align: left;">Summary<span class="s5">                           </span>16</p></li></ol></li></ol></li><li data-list-text="4"><h3 style="padding-top: 10pt;padding-left: 62pt;text-indent: -14pt;text-align: left;">Conclusion<span class="s5">                                 </span>17</h3></li></ol><p class="s9" style="padding-top: 34pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">Disclaimer: This work is part of the author’s ongoing journey in exploring advanced mathematics and physics, and as such, it represents a learning process in a challenging and new area of study. The content has not been peer-reviewed and may contain errors. The author welcomes feedback and corrections to help improve the accuracy and understanding of the material.</p><p style="padding-top: 14pt;text-indent: 0pt;text-align: left;"><br/></p><ol id="l9"><li data-list-text="1"><h1 style="padding-left: 71pt;text-indent: -24pt;text-align: left;">Introduction</h1><ol id="l10"><li data-list-text="1.1"><h2 style="padding-top: 8pt;padding-left: 78pt;text-indent: -30pt;text-align: left;">Background</h2><p style="padding-top: 5pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">Haskell is a purely functional programming language that emphasizes immutabil- ity, strong static typing, and higher-order functions [2]. The programming lan- guage is known for its expressive type system and its ability to enable concise and elegant code through the use of mathematical abstractions. One of the distinguishing features of Haskell is its foundation in category theory, a branch of mathematics that studies abstract structures and the relationships between them.</p><p style="padding-left: 47pt;text-indent: 14pt;text-align: justify;">Category theory was initially developed to formalize mathematical concepts across different fields, providing a unifying framework that could describe struc- tures and their interconnections. Central to category theory are the notions of objects and morphisms (arrows), which can be thought of as abstract represen- tations of entities and the functions or mappings between them [1].</p><p style="padding-left: 47pt;text-indent: 14pt;text-align: justify;">In recent decades, category theory has found significant applications in com- puter science, particularly in the field of functional programming [4]. Haskell, being a language deeply influenced by mathematical principles, incorporates many ideas from category theory directly into its core abstractions. Concepts such as functors, monads, and natural transformations, which are fundamen- tal in category theory, are directly implemented in Haskell’s type system and libraries.</p><p style="padding-left: 47pt;text-indent: 14pt;text-align: justify;">Understanding category theory is not just an academic exercise for Haskell programmers; it is essential for mastering the language’s powerful abstractions. The theoretical insights provided by category theory enable Haskell developers to write more general, reusable, and maintainable code. As a result, category theory has become an indispensable tool for both researchers and practitioners working with Haskell, bridging the gap between abstract mathematical concepts and practical software development.</p><p style="padding-top: 1pt;text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="1.2"><h2 style="padding-left: 78pt;text-indent: -30pt;text-align: left;">Motivation</h2><p style="padding-top: 5pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">The motivation for exploring category theory within the context of Haskell arises from the profound impact that these mathematical concepts have on the design, implementation, and understanding of functional programming in the language. Category theory provides a unifying language and framework that can describe and reason about the complex structures and patterns that emerge in Haskell programs.</p><p style="padding-left: 47pt;text-indent: 14pt;text-align: justify;">Haskell is unique in its deep integration of category-theoretic ideas, making it a powerful tool for developers who seek to leverage these abstractions to write expressive and composable code [2]. Concepts such as functors, monads, and natural transformations are not just theoretical constructs but are actively used in everyday Haskell programming. For instance, the Functor and Monad type classes in Haskell directly correspond to their categorical counterparts, enabling developers to apply powerful patterns like monadic composition and functorial</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 47pt;text-indent: 0pt;text-align: justify;">mapping in a rigorous and principled way.</p><p style="padding-left: 47pt;text-indent: 14pt;text-align: justify;">Despite its benefits, category theory is often perceived as abstract and chal- lenging, particularly for those new to functional programming. The steep learn- ing curve can be a barrier to fully harnessing the power of Haskell. However, gaining a solid understanding of these concepts is critical for utilizing the lan- guage’s full potential. This review aims to bridge the gap between theory and practice by delving into an introduction to category theory and demonstrating its practical applications in Haskell.</p><p style="padding-top: 2pt;text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="1.3"><h2 style="padding-left: 78pt;text-indent: -30pt;text-align: left;">Objectives</h2><p style="padding-top: 5pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">The primary objective of this paper is to provide a comprehensive yet acces- sible overview of category theory and its application in Haskell. By focusing on the core concepts of category theory, such as functors, monads, and natural transformations, the paper aims to demystify these abstract ideas and demon- strate how they are directly implemented in Haskell’s type system and standard libraries.</p><p style="padding-left: 62pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">Specific objectives include:</p><ol id="l11"><li data-list-text="1."><p style="padding-top: 8pt;padding-left: 72pt;text-indent: -12pt;text-align: left;">Introduce Fundamental Concepts:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 72pt;text-indent: 0pt;text-align: justify;">The paper introduces basic principles of category theory, starting with categories, objects, and morphisms, before progressing to more advanced topics like functors, monads, and natural transformations. The goal is to establish a clear understanding of these concepts, making them adaptable to functional programming.</p></li><li data-list-text="2."><p style="padding-top: 7pt;padding-left: 72pt;text-indent: -12pt;text-align: left;">Bridge Theory and Practice:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 72pt;text-indent: 0pt;text-align: justify;">One of the key objectives is to bridge the gap between the theoretical aspects of category theory and their practical applications in Haskell. By providing concrete examples and case studies, we’ll examine how category- theoretic concepts are not just abstract mathematical constructs but are essential tools for solving real-world programming problems in Haskell.</p></li><li data-list-text="3."><p style="padding-top: 7pt;padding-left: 72pt;text-indent: -12pt;text-align: left;">Enhance Code Comprehension and Design:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 72pt;text-indent: 0pt;text-align: justify;">Understanding category theory can significantly improve a developer’s ability to design and comprehend complex Haskell code. This paper is an exercise in becoming equipped with the knowledge needed to recognize and apply category-theoretic patterns, leading to more modular, compos- able, and maintainable software.</p></li><li data-list-text="4."><p style="padding-top: 7pt;padding-left: 72pt;text-indent: -12pt;text-align: left;">Clarify Terminology:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 72pt;text-indent: 0pt;text-align: justify;">The paper seeks to clarify few terminologies commonly used in Haskell that is rooted in category theory. By providing precise definitions and</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 72pt;text-indent: 0pt;text-align: left;">explanations, we aim to help eliminate confusion and promote a deeper understanding of the language’s abstractions.</p></li><li data-list-text="5."><p style="padding-top: 7pt;padding-left: 72pt;text-indent: -12pt;text-align: left;">Encourage Further Exploration:</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 72pt;text-indent: 0pt;text-align: left;">Finally, the paper aims to inspire readers to further explore category the- ory and its applications beyond the basics covered in this overview.</p><p style="padding-top: 5pt;text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li data-list-text="2"><h1 style="padding-left: 71pt;text-indent: -24pt;text-align: left;">Basic Concepts of Category Theory</h1><ol id="l12"><li data-list-text="2.1"><h2 style="padding-top: 8pt;padding-left: 78pt;text-indent: -30pt;text-align: left;">Categories</h2><p style="padding-top: 5pt;padding-left: 47pt;text-indent: 0pt;line-height: 86%;text-align: justify;">In category theory, a <i>category </i><span class="s10">C </span>is a mathematical structure that consists of two primary components: objects and morphisms (also called arrows) [3]. These</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: justify;">components must satisfy certain axioms that define how they interact. The formal definition is as follows:</p><p style="padding-top: 2pt;text-indent: 0pt;text-align: left;"><br/></p><ol id="l13"><li data-list-text="2.1.1"><h3 style="padding-left: 82pt;text-indent: -34pt;text-align: left;">Definition</h3><p style="padding-top: 5pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">A <i>category </i><span class="s10">C </span>is defined by:</p><ol id="l14"><li data-list-text="1."><p style="padding-top: 6pt;padding-left: 72pt;text-indent: -12pt;text-align: justify;"><i>A collection of objects</i>: The objects in a category can be anything, such as sets, spaces, types, or even other categories. We denote the objects in a category <span class="s10">C </span>by <i>A, B, C, . . .</i>.</p></li><li data-list-text="2."><p class="s9" style="padding-top: 6pt;padding-left: 72pt;text-indent: -12pt;text-align: justify;">A collection of morphisms<span class="p">: For each pair of objects </span>A <span class="p">and </span>B<span class="p">, there is a set of morphisms (arrows) between them, denoted by Hom</span><span class="s11">C</span><span class="p">(</span>A, B<span class="p">) or simply Hom(</span>A, B<span class="p">) when the context is clear. A morphism </span>f <span class="p">from object </span>A <span class="p">to object </span>B <span class="p">is written as </span>f <span class="p">: </span>A <span class="s10">→ </span>B<span class="p">.</span></p></li><li data-list-text="3."><p class="s9" style="padding-top: 6pt;padding-left: 72pt;text-indent: -12pt;line-height: 80%;text-align: justify;">Composition of morphisms<span class="p">: For any three objects </span>A, B, C <span class="p">in </span><span class="s10">C</span><span class="p">, if there is a morphism </span>f <span class="p">: </span>A <span class="s10">→ </span>B <span class="p">and another morphism </span>g <span class="p">: </span>B <span class="s10">→ </span>C<span class="p">, then there must exist a composite morphism </span>g <span class="s10">◦ </span>f <span class="p">: </span>A <span class="s10">→ </span>C<span class="p">. The composition operation </span><span class="s10">◦ </span><span class="p">must satisfy two properties:</span></p><ul id="l15"><li data-list-text="•"><p class="s9" style="padding-top: 7pt;padding-left: 94pt;text-indent: -9pt;line-height: 14pt;text-align: left;">Associativity <span class="p">: For any morphisms </span>f <span class="p">: </span>A <span class="s10">→ </span>B<span class="p">, </span>g <span class="p">: </span>B <span class="s10">→ </span>C<span class="p">, and</span></p><p class="s9" style="text-indent: 0pt;line-height: 14pt;text-align: center;">h <span class="p">: </span>C <span class="s10">→ </span>D<span class="p">, the following must hold:</span></p><p class="s9" style="padding-top: 6pt;padding-left: 44pt;text-indent: 0pt;text-align: center;">h <span class="s10">◦ </span><span class="p">(</span>g <span class="s10">◦ </span>f <span class="p">) = (</span>h <span class="s10">◦ </span>g<span class="p">) </span><span class="s10">◦ </span>f</p></li><li data-list-text="•"><p class="s9" style="padding-top: 10pt;padding-left: 94pt;text-indent: -10pt;line-height: 82%;text-align: justify;">Identity <span class="p">: For each object </span>A <span class="p">in </span><span class="s10">C</span><span class="p">, there exists an identity morphism id</span><span class="s12">A</span> <span class="p">: </span>A <span class="s10">→ </span>A <span class="p">such that for any morphism </span>f <span class="p">: </span>A <span class="s10">→ </span>B <span class="p">and </span>g <span class="p">: </span>C <span class="s10">→ </span>A<span class="p">, the following holds:</span></p><p class="s9" style="padding-top: 9pt;padding-left: 45pt;text-indent: 0pt;text-align: center;">f <span class="s10">◦ </span><span class="p">id</span><span class="s12">A</span> <span class="p">= </span>f <span class="p">and id</span><span class="s12">A</span> <span class="s10">◦ </span>g <span class="p">= </span>g</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li></ol></li><li data-list-text="2.1.2"><h3 style="padding-left: 82pt;text-indent: -34pt;text-align: left;">Example of a Category: The Category of Sets</h3><p style="padding-top: 6pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">One of the most familiar examples of a category is the category <span class="h3">Set</span>, where:</p><ul id="l16"><li data-list-text="•"><p class="s9" style="padding-top: 5pt;padding-left: 72pt;text-indent: -9pt;text-align: left;">Objects<span class="p">: The objects are all sets.</span></p></li><li data-list-text="•"><p class="s9" style="padding-top: 5pt;padding-left: 72pt;text-indent: -9pt;text-align: left;">Morphisms<span class="p">: The morphisms are functions between sets.</span></p></li><li data-list-text="•"><p class="s9" style="padding-top: 7pt;padding-left: 72pt;text-indent: -10pt;line-height: 82%;text-align: justify;">Composition<span class="p">: The composition of two functions is the usual composition of functions, where for functions </span>f <span class="p">: </span>A <span class="s10">→ </span>B <span class="p">and </span>g <span class="p">: </span>B <span class="s10">→ </span>C<span class="p">, the composite </span>g <span class="s10">◦ </span>f <span class="p">: </span>A <span class="s10">→ </span>C <span class="p">is defined by (</span>g <span class="s10">◦ </span>f <span class="p">)(</span>x<span class="p">) = </span>g<span class="p">(</span>f <span class="p">(</span>x<span class="p">)).</span></p></li><li data-list-text="•"><p class="s9" style="padding-top: 6pt;padding-left: 72pt;text-indent: -10pt;line-height: 88%;text-align: justify;">Identity <span class="p">: The identity morphism for any set </span>A <span class="p">is the identity function id</span><span class="s12">A</span> <span class="p">: </span>A <span class="s10">→ </span>A<span class="p">, defined by id</span><span class="s12">A</span><span class="p">(</span>x<span class="p">) = </span>x <span class="p">for all </span>x <span class="s10">∈ </span>A<span class="p">.</span></p></li></ul><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2.1.3"><h3 style="padding-left: 82pt;text-indent: -34pt;text-align: left;">Visualization</h3><p style="padding-top: 6pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">The structure of a category can be visualized using a diagram, where objects are represented as nodes, and morphisms are represented as arrows between these nodes. Consider the following diagram:</p><p class="s13" style="padding-top: 6pt;text-indent: 0pt;text-align: center;">id<i>C</i></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="text-indent: 0pt;line-height: 15pt;text-align: left;">C</p><p class="s13" style="text-indent: 0pt;line-height: 15pt;text-align: left;">g</p><p class="s13" style="text-indent: 0pt;line-height: 15pt;text-align: left;">A</p><p class="s13" style="text-indent: 0pt;line-height: 15pt;text-align: left;">f</p><p class="s13" style="text-indent: 0pt;line-height: 15pt;text-align: left;">B</p><p style="text-indent: 0pt;text-align: left;"><span><table border="0" cellspacing="0" cellpadding="0"><tr><td><img width="22" height="17" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAARCAYAAADZsVyDAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACbElEQVQ4ja1Uz2saQRid1TVr10bZ7SWwjaS1UNkQyNqDkD015mbAtDEQ7CmQHs1f0ATqX9CSU6DgQZHSJPQXOUXrodicEguFZQWNWg304oi7umKzM9NTfyVia+0H7/LN4/F9M+8NIISAUbC4uPimX98CRqx6vX6dEHKpP7KwIAhnpVLJ89+FV1dXn8fj8bWLfarfGu1223F6enoTQsiXy+Ubqqp6bTbbOcdxTY7jmjzPw4mJiS+CIJxxHNeUZTmXSqUi09PTyiVhQghQVdUbj8fXDg4Ogm63+7MoisrMzMwnURQVhJAVQshDCPlGo3Ht+Pj4TqFQuN3pdBwul6ulqqo3k8kEJEn6+EPQMAz75ubmY1mW3x8eHgba7TaLMR7oBowx0DTtaiwWeyQIQs3v9x/t7e3d/35OI4QskUgk5fP5TjKZTIBhmK9/c7eapjlXVlZ25+bmPiiKIo6Pj+sURf0k7OzsPNzY2Hjypwl/hWmaluXl5d1kMhnBGFP9OMDv9x/puu4YJhT7+/v3otHo00HDgNnZ2ZNh09bpdK70ej3bII6FYZheq9VyDuNdlmW7Y2Nj54M4lqWlpVfb29vRfn4eqbrdLhMMBt8mEokHCKG+D/EvAIQQ0Gw2XeFw+EUoFHpZqVTcCCFqGJdgjAHGGCCEKF3XHdVqdfK35KXT6YVYLLZF07Q5Pz//LhQKvfZ4PCWWZY2Lm5qmSUMIeVVVvblcTs7n81KxWLzldDq19fX1Z33/imq16k6n0wvZbPZurVabNAyDRQhZCSEURVHEarUimqZNnufh1NRUxefznUiSlBdFUbHb7T0AAPgGVWRytgn+GnsAAAAASUVORK5CYIIA"/></td></tr></table></span><span><table border="0" cellspacing="0" cellpadding="0"><tr><td><img width="22" height="17" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAARCAYAAADZsVyDAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACjUlEQVQ4ja1UTUsbURS9MxPbTulMSloEDcaIMppFqYtJVm6iWKsoJLRm0UIFEfwD2l21xY2F/oFCCRbdNJhshCoW66aLYrKoLrQJDTOkXxBwtBnJG8i8d7tpgpqooe2Bu7nv3vPOOxweh4gAAEAp5TOZjJJMJv2pVErVdd27v79/gxAiwinIslxwu93fe3t73w8ODq42NTX9BADgOK4ywy0uLj6MRqPjhmG4Ojs706qqpvx+f7Kjo+OLy+UyRFEkx5cQEUzTlHRd966vr99ZW1u7SwgRZ2dnn/X397+rkGua1prP528yxgARa9bxs9NzjDHQNK11dHT0TTgcjhuGcR0R4UyyeonLPcYYLC0tPRgYGFi1LOsSV/b4PCDiCSuOe1nulTE3N/ekoaGh9F8VIyIcHBw4A4HAR8d5SkulkgMAwOFw2Bc+6w+cTucvQojInzVAKeUnJydfbm5uBuslBQA4Ojq6JooiqUmMiBCNRseLxeLVvr6+jXpJERGmpqZeTExMvKry6/DwUJ6enn4eCoUSxWLxSr0e27bNz8zMPA2FQglKKVdRnEgkwsPDwyuqqqbcbve35eXl+6IoWheptCzrcjwev9fT0/OB53kWi8UiPM9jJW47Ozu3RkZGVjweT44QIgqCQLu7uz8pipKRZbkgSZIpSZIpCALN5XIeXde92Wy2fW9vzzc0NPR2bGzstc/n+1y+8ESO0+m0EolEYltbWwHGGL+9vX07m822FwoF2TRNyTRNybZtR0tLy1ev16u3tbVpiqJkeJ5nACf/iiq/5ufnHy8sLDz62xyXq2pod3e3KxgMblBKuX8hropbc3PzD8MwXJRSod6Y1UIVsSzLhcbGxjwicrUW6sVvN1BVY1qu1NAAAAAASUVORK5CYIIA"/></td></tr></table></span><span><table border="0" cellspacing="0" cellpadding="0"><tr><td><img width="17" height="22" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAWCAYAAAAmaHdCAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAC1UlEQVQ4jXVUz2sTURCet5toEiqamFpEG6g92CZYSc2hpJcmKLkUSy1pCyIiufkPqIQeJLT9D3opEnooRFoP5pIuBHOweCgktZBfF2uIBIraLG3TbJPszvPi09fNdmDYx5uZb+Z9OzNAKQWmzWbTsry8/GpsbOyL1+vN+v3+7dXV1Uin0xF5P70K8FdkWb42Nzf3vt1uX5IkKZTNZh9IkhTK5XKj8/PzCUVRLKATSun/AyLC7OxsYm1t7RkinsuCiLCwsPA2FotF9TamgIggSdKj6enpD5qmERbIOymKctnv92+XSqW7RkkAEWF8fPxztVq9zTvoz6lUKhSNRmOI2JUEKpWKKxgMpjVNIxeVi4jQaDRsbrc7f3p6atXbhHQ6/TAQCGQIIZQQ0kUcI89mszX7+/t/7O/v3+HthBAQMplMYGpq6mMX4wDAQAkhQAiB4eHhkizLdr1dqNVqtwYHB7/xATwYX53H4ylUq1XXOT4AQGg2mzar1aroe0APBgDgdruL5XJ5SA8uaJom6gH0lbCsqqqazGZzh939ew6llBiBGHFUr9cdDoejrq/EJAgCGnHAO7EzD8LHCAxEL4qiWLa2tkL8cw8PD6/b7XaZT0gIAcFkMqmqqprYBcsgiqKWTCYfh8PhjZOTkx5KKeRyuVGn0/lb308wOTmZPDg4uGHUqaqqColEYjYUCqUajYbN5/Pt1Gq1m4gImqaRdrttarVaZtPAwMD3crk81NfX95Mxzr6iKGI4HN4oFAqelZWVl2dnZxa73S6vr68/jcfjL+r1uqO3t/cXxOPx54uLi2/Y3BhNqSzLV10uV2ViYuLTyMjI16WlpdfFYnHo6OjoCiIC7O7u3p+ZmdkwCmZfRASfz7fjdDp/5vN5d9c+abVaZq/Xm2W75CLd3Nx8sre3d89wKVFKIRgMpo+Pj3uMVsBFoLxNAACIRCLv+OnkG4kfNF743/wHjAKgjoGr8aUAAAAASUVORK5CYIIA"/></td></tr></table></span><span><table border="0" cellspacing="0" cellpadding="0"><tr><td><img width="7" height="9" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAJCAYAAAD+WDajAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAo0lEQVQYlW2NMQ6CQBBFvyTrAXSyDXZ2Bgt6Kjpt9wgkHop4BOkIlZ01BYmUdFtsZPcCmMzYGQP+5FcvLw8igt+HEDbGmJuIIMJsfd8fiMgDWEJr7S6OY/sXaq1f3nsCAMyb4zhu0zRtmXlpElFIkuRZVZVZiQiYOWqa5lSW5WUYhv00TWul1BvOOZ3n+b0oimvXdUdm/iaQZdmjruvzvC0i+ADKA20PWhvJEAAAAABJRU5ErkJgggAA"/></td></tr></table></span></p><p class="s13" style="text-indent: 0pt;text-align: center;">id<i>A</i><i>              </i>id<i>B</i></p><p style="padding-top: 11pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">In this diagram:</p><ul id="l17"><li data-list-text="•"><p style="padding-top: 4pt;padding-left: 72pt;text-indent: -9pt;text-align: left;">Objects are red nodes <i>A</i>, <i>B</i>, and <i>C</i>.</p></li><li data-list-text="•"><p style="padding-top: 5pt;padding-left: 72pt;text-indent: -9pt;text-align: left;">Identity morphisms are id<i>A</i>, id<i>B</i>, and id<i>C</i>.</p></li><li data-list-text="•"><p class="s9" style="padding-top: 4pt;padding-left: 72pt;text-indent: -9pt;text-align: left;"><span class="p">Two other morphism exist, </span>f <span class="p">: </span>A <span class="s10">→ </span>B <span class="p">and </span>g <span class="p">: </span>C <span class="s10">→ </span>B<span class="p">.</span></p></li></ul></li><li data-list-text="2.1.4"><h3 style="padding-top: 11pt;padding-left: 82pt;text-indent: -34pt;text-align: left;">Axioms and Properties</h3><p style="padding-top: 6pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">The structure of a category encapsulates two critical properties:</p><ul id="l18"><li data-list-text="•"><p class="s9" style="padding-top: 4pt;padding-left: 72pt;text-indent: -10pt;text-align: justify;">Associativity <span class="p">: the way we compose morphisms does not depend on how the composition is grouped</span></p></li><li data-list-text="•"><p class="s9" style="padding-top: 6pt;padding-left: 72pt;text-indent: -10pt;text-align: justify;">Identity <span class="p">: every object has a morphism that behaves as a neutral element for composition, maintaining the integrity of other morphisms</span></p></li></ul><p style="padding-top: 4pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">These properties ensure that categories form a robust framework for under- standing mathematical structures and relationships, making them foundational to both category theory and its applications in areas like Haskell.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2.1.5"><h3 style="padding-left: 82pt;text-indent: -34pt;text-align: left;">Categories in Haskell</h3><p style="padding-top: 6pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">In Haskell, categories provide the basis for understanding various abstractions such as <i>types </i>and <i>functions </i>[2]. The objects of a category can be represented by types, while morphisms correspond to functions between these types. The composition of functions and the identity function in Haskell naturally align with the composition and identity axioms of category theory.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 47pt;text-indent: 0pt;text-align: justify;">For example, in Haskell:</p><ul id="l19"><li data-list-text="•"><p style="padding-top: 8pt;padding-left: 72pt;text-indent: -10pt;text-align: left;">The function <span class="s16">factorial n = n * factorial (n - 1) </span>defines a recur- sive factorial calculation.</p></li><li data-list-text="•"><p style="padding-top: 8pt;padding-left: 72pt;text-indent: -9pt;text-align: left;"><i>Objects</i>: Haskell types (e.g., <span class="s6">Int</span>, <span class="s6">Bool</span>, <span class="s6">Maybe Int</span>).</p></li><li data-list-text="•"><p class="s16" style="padding-top: 7pt;padding-left: 72pt;text-indent: -10pt;text-align: left;"><span class="s9">Morphisms</span><span class="p">: Haskell functions (e.g., </span>f :: <span style=" color: #00F;">Int </span>-&gt; <span style=" color: #00F;">Bool</span><span class="p">, </span>g :: <span style=" color: #00F;">Bool </span>-&gt; <span style=" color: #00F;">Maybe Int</span><span class="p">).</span></p></li><li data-list-text="•"><p style="padding-top: 8pt;padding-left: 72pt;text-indent: -9pt;text-align: left;"><i>Composition</i>: Function composition <span class="s16">(.)</span>, where <span class="s16">(g . f) x = g (f x)</span>.</p></li><li data-list-text="•"><p style="padding-top: 7pt;padding-left: 72pt;text-indent: -9pt;text-align: left;"><i>Identity </i>: The identity function <span class="s6">id </span><span class="s16">:: a -&gt; a</span>, where <span class="s6">id </span><span class="s16">x = x</span>.</p></li></ul><p style="padding-top: 7pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">Understanding this categorical perspective allows Haskell developers to harness the power of abstract mathematical reasoning in practical programming, leading to more flexible and reusable code.</p><p style="padding-top: 2pt;text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li data-list-text="2.2"><h2 style="padding-left: 78pt;text-indent: -30pt;text-align: left;">Functors</h2><p style="padding-top: 5pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">In category theory, <i>functors </i>are mappings between categories that preserve their structure. Functors are essential in relating different categories and allowing us to apply category theory to various areas, including functional programming in Haskell.</p><p style="padding-top: 2pt;text-indent: 0pt;text-align: left;"><br/></p><ol id="l20"><li data-list-text="2.2.1"><h3 style="padding-left: 82pt;text-indent: -34pt;text-align: left;">Definition of a Functor</h3><p style="padding-top: 6pt;padding-left: 47pt;text-indent: 0pt;line-height: 86%;text-align: justify;">A <i>functor F </i>from a category <span class="s10">C </span>to a category <span class="s10">D</span>, denoted as <i>F </i>: <span class="s10">C → D</span>, consists of two components:</p><ol id="l21"><li data-list-text="1"><p style="padding-top: 7pt;padding-left: 72pt;text-indent: -9pt;line-height: 14pt;text-align: left;"><i>Object Mapping </i>: For every object <i>A </i>in <span class="s10">C</span>, there is an associated object</p><p style="padding-left: 72pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><i>F </i>(<i>A</i>) in <span class="s10">D</span>.</p></li><li data-list-text="2"><p style="padding-top: 6pt;padding-left: 72pt;text-indent: -10pt;line-height: 78%;text-align: left;"><i>Morphism Mapping </i>: For every morphism <i>f </i>: <i>A </i><span class="s10">→ </span><i>B </i>in <span class="s10">C</span>, there is an associated morphism <i>F </i>(<i>f </i>) : <i>F </i>(<i>A</i>) <span class="s10">→ </span><i>F </i>(<i>B</i>) in <span class="s10">D</span>.</p></li></ol><p style="padding-top: 7pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">These mappings must satisfy the following properties:</p><ul id="l22"><li data-list-text="•"><p style="padding-top: 8pt;padding-left: 72pt;text-indent: -10pt;line-height: 86%;text-align: left;"><i>Preservation of Identity </i>: For every object <i>A </i>in <span class="s10">C</span>, the functor <i>F </i>must satisfy:</p><p class="s12" style="padding-left: 23pt;text-indent: 0pt;text-align: center;"><span class="s9">F </span><span class="p">(id</span>A<span class="p">) = id</span>F<span class="s9"> </span><span class="s17">(</span>A<span class="s17">)</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="•"><p class="s9" style="padding-left: 24pt;text-indent: -9pt;line-height: 14pt;text-align: center;">Preservation of Composition<span class="p">: For any two morphisms </span>f <span class="p">: </span>A <span class="s10">→ </span>B <span class="p">and</span></p></li></ul><p class="s9" style="padding-left: 72pt;text-indent: 0pt;line-height: 14pt;text-align: left;">g <span class="p">: </span>B <span class="s10">→ </span>C <span class="p">in </span><span class="s10">C</span><span class="p">, the functor </span>F <span class="p">must satisfy:</span></p><p class="s9" style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;text-align: center;">F <span class="p">(</span>g <span class="s10">◦ </span>f <span class="p">) = </span>F <span class="p">(</span>g<span class="p">) </span><span class="s10">◦ </span>F <span class="p">(</span>f <span class="p">)</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2.2.2"><h3 style="padding-left: 82pt;text-indent: -34pt;text-align: left;">Example: Functor in the Category of Sets</h3><p style="padding-top: 7pt;padding-left: 47pt;text-indent: 0pt;line-height: 92%;text-align: justify;">Consider the category <span class="h3">Set</span>, where objects are sets and morphisms are functions. A simple example of a functor <i>F </i>: <span class="h3">Set </span><span class="s10">→ </span><span class="h3">Set </span>is the power set functor <span class="s10">P</span>, which maps each set to its power set (the set of all subsets), and each function to its image map.</p><ul id="l23"><li data-list-text="•"><p style="padding-top: 8pt;padding-left: 24pt;text-indent: -9pt;line-height: 14pt;text-align: center;"><i>Object Mapping </i>: For each set <i>X </i>in <span class="h3">Set</span>, <span class="s10">P</span>(<i>X</i>) is the power set of <i>X</i>, i.e.,</p><p class="s10" style="padding-left: 72pt;text-indent: 0pt;line-height: 14pt;text-align: left;">P<span class="p">(</span><span class="s9">X</span><span class="p">) = </span>{<span class="s9">U </span>| <span class="s9">U </span>⊆ <span class="s9">X</span>}<span class="p">.</span></p></li><li data-list-text="•"><p style="padding-top: 6pt;padding-left: 72pt;text-indent: -10pt;line-height: 78%;text-align: left;"><i>Morphism Mapping </i>: For each function <i>f </i>: <i>X </i><span class="s10">→ </span><i>Y </i>in <span class="h3">Set</span>, <span class="s10">P</span>(<i>f </i>) : <span class="s10">P</span>(<i>X</i>) <span class="s10">→ P</span>(<i>Y </i>) is defined by <span class="s10">P</span>(<i>f </i>)(<i>U </i>) = <span class="s10">{</span><i>f </i>(<i>u</i>) <span class="s10">| </span><i>u </i><span class="s10">∈ </span><i>U </i><span class="s10">} </span>for each subset <i>U </i><span class="s10">⊆ </span><i>X</i>.</p></li></ul><p style="padding-top: 9pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">The power set functor preserves the identity and composition, making it a valid functor.</p><p style="padding-top: 2pt;text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2.2.3"><h3 style="padding-left: 82pt;text-indent: -34pt;text-align: left;">Visualization</h3><p style="padding-top: 6pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">Functors can be visualized with diagrams that illustrate how objects and mor- phisms are mapped between categories.</p><p style="padding-left: 47pt;text-indent: 14pt;line-height: 78%;text-align: left;">Consider the following diagram, where <i>F </i>is a functor from category <span class="s10">C </span>to category <span class="s10">D</span>:</p><p style="text-indent: 0pt;text-align: left;"/><p class="s18" style="padding-top: 10pt;text-indent: 0pt;text-align: center;">A     <span class="s19">f     </span><span class="s20">/</span><span class="s21">¸ </span>B</p><p style="padding-top: 7pt;text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">In this diagram:</p><p class="s22" style="padding-top: 3pt;padding-left: 53pt;text-indent: 0pt;text-align: left;">F             F</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"/><p class="s20" style="text-indent: 0pt;line-height: 10pt;text-align: left;">/<span class="s21">¸</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s23" style="padding-left: 50pt;text-indent: 0pt;line-height: 6pt;text-align: left;"> <span class="s24">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class="s25">F </span><span class="s26">(</span><span class="s25">f</span><span class="s22"> </span><span class="s26">) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class="s27"> </span></p><p class="s9" style="padding-left: 38pt;text-indent: 0pt;line-height: 10pt;text-align: left;">F <span class="p">(</span>A<span class="p">)        </span>F <span class="p">(</span>B<span class="p">)</span></p><ul id="l24"><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 72pt;text-indent: -10pt;line-height: 78%;text-align: left;">The objects <i>A </i>and <i>B </i>in category <span class="s10">C </span>are mapped to objects <i>F </i>(<i>A</i>) and <i>F </i>(<i>B</i>) in category <span class="s10">D</span>.</p></li><li data-list-text="•"><p style="padding-top: 5pt;padding-left: 72pt;text-indent: -9pt;line-height: 14pt;text-align: left;">The morphism <i>f </i>: <i>A </i><span class="s10">→ </span><i>B </i>in <span class="s10">C </span>is mapped to the morphism <i>F </i>(<i>f </i>) : <i>F </i>(<i>A</i>) <span class="s10">→</span></p><p style="padding-left: 72pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><i>F </i>(<i>B</i>) in <span class="s10">D</span>.</p><p style="padding-top: 6pt;padding-left: 47pt;text-indent: 0pt;line-height: 78%;text-align: justify;">Now, lets review a more elaborate example (below) of functors, <i>F </i>: <span class="s10">C → D</span>. Left diagram of red nodes and morphisms are in category <span class="s10">C </span>and right diagram of green nodes and morphisms are in category <span class="s10">D</span>:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 1pt;text-indent: 0pt;line-height: 11pt;text-align: left;">id<i>C</i></p><p style="text-indent: 0pt;line-height: 11pt;text-align: center;">F(C)</p><p style="padding-top: 3pt;text-indent: 0pt;text-align: center;">C             <span style=" color: black; font-family:&quot;Bookman Old Style&quot;, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: 1pt;">F(C)</span></p><p style="padding-top: 2pt;padding-left: 30pt;text-indent: 0pt;text-align: left;"><span style=" color: black; font-family:&quot;Bookman Old Style&quot;, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: 6pt;">g            </span>F(g)</p><p style="padding-left: 1pt;text-indent: 0pt;line-height: 11pt;text-align: left;">A</p><p style="padding-left: 1pt;text-indent: 0pt;line-height: 11pt;text-align: left;">f</p><p style="padding-left: 1pt;text-indent: 0pt;line-height: 11pt;text-align: left;">F(B)</p><p style="padding-left: 1pt;text-indent: 0pt;line-height: 11pt;text-align: left;">B  id<i>B</i></p><p style="padding-left: 1pt;text-indent: 0pt;line-height: 11pt;text-align: left;">F(X)</p><p style="padding-left: 1pt;text-indent: 0pt;line-height: 11pt;text-align: left;">F(A)</p><p class="s22" style="padding-left: 1pt;text-indent: 0pt;line-height: 12pt;text-align: left;"><span class="s28">id</span>F <span class="s29">(</span>A<span class="s29">)</span></p><p style="text-indent: 0pt;text-align: left;"><span><table border="0" cellspacing="0" cellpadding="0"><tr><td><img width="21" height="21" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVCAYAAACpF6WWAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAADUklEQVQ4jW1VPU8bWRQ9d17EGswwggEiZcV2STMhWn80pBikRZqCKH8AK5EcuhWhIeQHbGmJJstS7YYokvMHdqGwxEpQrFIwtgRMCpoUKyEZNERmsHEzc1N43uPZyVR+njvnnXPuefdRkiQgIsiHmQEAtVrNOzg4cBv1ej4KgsJ0FE2dm+aF6Th+Lp+vu6574HleDUDf9wBAOigzIwxDe7lc3nZ8/8miadLD4WGyhAABYACtOMbJzQ12oyj5VCzu/Pn2bdm27VAHJ8mMmfGhWi1tvn795nfLGi9ks70CQNHgHq76/7Dd5pVW68vLSmV1qVSqStA7EvRDtVr6b23t/d69ezRiGKQD6EApAWaAi9ks/ZvJTKyvrb0HAAlMSZIgDEP76aNHp3t3704MC8FgvmU44FcqC/q7Thzjl2bz8p+jowe2bYcGACyXy+82LWt8pOcdKSC9gTpzIvWOAR4RApuWNb5cLm8DgJibm/M6W1u/PbPtnmRmEJGSr3tKRARmMBETQKqWmX8cGqLj09P78ezsRzEzM/Ni8fNn96ehIVDvOwKzYkJEJJkpFel7WUsAMRFnAGMvm/1fmKOjr37tdu//YBhMzLcAzKRboRin7FRtagcBNCYE/ri+vjaiICiMCcEE9HWcifi7nkovifrXAFtCIAqCgjEdRVNKRho0ZmZivt1ESkzXDPRUDUaOCNNRNGWcm+aFzKoeFdUMuWZWa715CjA9SOemeWGYjuNfxbECkgV9TGXD5MZaIyURBrgVxzAdxzd+zuUax90uZJxUkc5U85QlbCpP/iaATm5uOJfPN4z5+fn93VaLVZxSqQqIuc9jlQj9pBGBAd6NInZdd9/wPK8WFIs7frvdAwBYz5/Mow4o46YOCDP57TaCQmHH87zaN2d/RAjFVPn4nUclgAidOMZCs3n599HRg8nJydAgIti2Ha5UKqvrZ2dJJ445FUdyGuF2PPZPrhRw/ewsWalUVuVcNWS+lkql6uONjecLzeYXv9NRTPWjOTgTDtttXmg2Lx9vbDzX5ynpm2uT/51zePhk0bJoNpPBmBDo2cy4imMcd7vYvbpKgkJh56/t7bJt26HuFA0qGrij5hv1ek6/o0Ydx8/n8w3Xdff1O0rH+QojBvAupb8CKwAAAABJRU5ErkJgggAA"/></td></tr></table></span><span><table border="0" cellspacing="0" cellpadding="0"><tr><td><img width="21" height="21" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVCAYAAACpF6WWAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACkUlEQVQ4jbWVzUsbYRDGZ3aDX0s2KdlshZL2ULw0FXQ36CGlEdxCKC302AhSCCKlqM3Bv6BH9ZC2CuqhPQhJj6W2EqiCB3PwI3uJae1BLw3EJhGTDbvxEDM9mBS/WtOaPsfhnR/POzDPIBHBaRERRCIRbzQadauqKmvxuMtWKAh7ZnPW0t6+3ilJqtvtjnq93gginuhDRMDT0N3d3atPBwdnb66tPXzA8yi1tJDFZMJKF+QPDyFmGPRJ02C7u3t+emZmsLW19ce5UCKCcCjU93p0dDJotVq7OA4QAImIsGqHCAARqrVVXadALpcbnpgY8vX1hQAAEBFMVeC7cNi3GAjMLTkcTDPi2Zmco26Ow6WmpitDgcAcItJjny8McOQE0um0/VFn55fPoihwLAt09I8LnVZrerkM9zKZ7HtVvSWKYoYhIhjw+9++4nkbx7K1GDwjjmXhpdlsG/D73xARsG63W9Gmpl48EQQ88bLitDInPF4/r3atoQHVra027OiIstcdDv/9nZ27Nxob4TJQAIBmRFjiuO8sx3Gjzw4O2poY5tJQC8vCZKGgM4VEQraaTBeNrSZZTCbQEgmZETRNrAuxIpumiUyW59P1hO7xfJoxO52xXKlUF2C+VALe6YwxsiSp8WKxLtB4sQiSLKuMp6dneT6fr2ktL9KHfB48Hs8yoyjK4leXa2FD1y8FXtd1+uZyLSiKsvh/dh8AwG63Z4bGx5+PJJNlo1z+K4cGEQwnk+XhsbERu92eAQBgAI4y0OfzhXqDwf7eVGp/zTBqAq7qOvWmUvtKMNhfjT0A+LfkVw2DPmoabHd1zU/Pzv4++Y/r141aWbmjqqqkbW66hEJByJrNWf727Q1JlmN/ulE/AXzBZhj5e3VjAAAAAElFTkSuQmCC"/></td></tr></table></span><span><table border="0" cellspacing="0" cellpadding="0"><tr><td><img width="21" height="21" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVCAYAAACpF6WWAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACoklEQVQ4jbWVwUvbUBzHf0mLWruk3Za4CIJeNhCzg2mph5WtYIUgbIedZkSY3SjCrHqY/8CO0kMd4kE2PWxrj4MpIrQyC16GbTws0h02YfSgph0uDWkR2vx2maXqnE67L/wuv8f78H3vx3tfAhHhuBAREomEP7m25kvLslBQFBej6y15ilJpnk+7BEG+5/Ot+f3+BEEQJ/YTpmkeaeRyOfZJILDQmUr133c44LbNBg6rtbqulcvwuVSCRU2DL2738qv5+WGWZXNHoIdOERFisZg0Mzk5/ZKmr7ubm09aOKZUsYhjuv4jNDU19mhgIHboumohFo1KqxMTb+JtbaTdYjmLBwAAbrudiDc1MWPj428RkZAGB6NVp7u7uzcedndnVltbr9pI8lzAWhVNE3p3dvbfb252chy3RyIijASDcxGn03kRIABAM0lCxOl0jgSDc4gIlp6eHlGbnX0xzDBn3uHf1NbQQGxkMrdMnv9k6Whvfyxub9/taGy8DBMAABoAiCRNf7dcsdufhw4ObjZe8Oi1umaxwIyuG2RBUdz0Oad9lhxWKxQUxU0yus7UhfhbjK4zZJ6i8vWE5ikqT9I8nypUKnUBauUy0DyfIrsFQZaLxbpA5WIRBEGQSa/Xu76kaYgAl66lQgHveL3rpCiKK189nsUNwwACkbhobRgGfPN4FkVRXPk/bx8AgOO4vWfhcGg0mzWNfxyaUalAKJs1Q+HwKMdxewAAVVuSJL3rjUSG+lQ1nzKMk3HwB6UMA/tUNe+fnh4akKToYZ+ojRNEBFVVW54GAvOd6XT/A4eD4G02cNb8/D/LZVBKJfigaZhxuZZfLywMsyybq40V4rSMisfjfclk0ien00Jha0tgdb0lR1Eq3dUlCy6X7PP5Pp6WUb8AmVZq4u8W1L4AAAAASUVORK5CYIIA"/></td></tr></table></span><span><table border="0" cellspacing="0" cellpadding="0"><tr><td><img width="14" height="11" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAALCAYAAABPhbxiAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABhklEQVQokX1Rv0sCcRR/7/QulRBRh2gQ9JIa70ySIEVcnRojd5f+AQeRpv4Bl2YHR4d2IRclsHNTOTihQUS7iNBSz+/7Nn1BhXrweB/e7/c+wDmHfSWiHUxEkEwmXxhjKGIS5xz2BRF3MCKCz+f7JiJJxFyVSgUQUUxAx3FkxphrtVod2LYdkmXZEQ0Mw9B1XTcQEdwAAOv1Wm40GtfVavXO6/X+hMPhd7/f/xUIBD4Hg8GZZVkxRVFWlmWp0Wh0lMvlmrBYLLzpdPq5VqvdzmazkLhp+8bhcBhXVdUsl8v3pmmqRASQz+efOp3OxV/PmU6nYV3Xu6Kp8EM2m23+99VWq3XV7/dPt32cc4BUKtXebDbSdsH+qvuWiMBVKBRORqNRLJFIvEqStEODoEpQskMRYwxLpdKDbduhYrH4qGlaz+12b0Qi5xwQEYgIx+PxsWma8eVy6UEiAgCAbrd7Xq/Xb9rt9mUwGPzweDxLRVHWsiw7k8nkaD6fH0YikTdN03qZTKb1C5kTNKVTc4c9AAAAAElFTkSuQmCC"/></td></tr></table></span><span><table border="0" cellspacing="0" cellpadding="0"><tr><td><img width="14" height="11" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAALCAYAAABPhbxiAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABbElEQVQokZWRQUvCYBjHn3dbbChrBeHRpLvQIZhtNPoEgl5M8JTnhA5+iA5C4DkPHYwutY8w0a3Ci90Fx3scCM7haG49b6eiTKEe+J/+/A6//0MGg4HmOI42Go0OKaVZURSjTCbjJUkixHG8FUWR6Pu+UigUnsvl8oOmaQ4hBKDb7Z6Zpll0XTeLiMAY+5U4jvl+v6/XarXbZrN5lSQJRxARCCHwl2OMQbvdvqCUZv8FAgAgItF13eZWi+FweGTbtrYJ5DiOSZL0Bt+9JpPJfj6ff51Op7vrXBlj0Ov1TorFogmICLZtHzcajWtVVZ/G4/HBOsDzvL1Wq3VpGIbl+75MEBEsyzotlUqPqqq+LBaLtKIofi6Xc8MwTAVBIM9msx1BEJJqtXpXqVTuJUmKCCICAECn0zlnjJF6vX4zn8+3KaXZdDq9kGU5kGU5EEUx+jHip+NyuRQMw7A2ua3ma1We59/DMEwxxv70lg8qpgTBQKqR8AAAAABJRU5ErkJgggAA"/></td></tr></table></span><span><table border="0" cellspacing="0" cellpadding="0"><tr><td><img width="11" height="14" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABiklEQVQokXXQT2rCQBQG8DcxYkDyh9bujHTR4gVEbUcRwXoA3aYUeoBSXIhHcFHEAwhC3bfbUhel0Uj0CK5EswuBaFBS2pnpohhSaR/M5nu/eYsPMcaAEMK1Wq22YRhYEARfFEVvMBhcS5LkQXgopdBsNtvdbveOEIIYY6DreqFYLL7vdjuBMQb7B+Px+FLTtEdKKYQXnU7nvt/v3/zCjUbjYTQa4XDIGAPbto+r1epL+AhnmmY+n8+bcDCJRMKhlHK+7wv7jJNlec3zPDnEAACKoribzUYKcCwW+/gLAgCIouh5nicGOBqNfv6H4/H4drvdxgPM8/xXGEwmkwvHcY4AABaLxWkqlVoG2LbtkzAWBMEvl8tv8/n83HVdRVEUFwB+qisUCvphx8vlMpnNZs1KpfLa6/VuS6XSWyaTmXGqqq5Wq5Uavq6qqoUxNmazWZYxhobD4dV0Os1FNE07I4Tw6XR6Hv4gy/K6Vqs91+v1p0gkQhFCwGOMDcuykodN5HK5KQAAQijIvgElm9cFS4c4lwAAAABJRU5ErkJgggAA"/></td></tr></table></span><span><table border="0" cellspacing="0" cellpadding="0"><tr><td><img width="24" height="17" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAARCAYAAADHeGwwAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACtklEQVQ4jaVUz0/aUBx/LZWqLDAOTjcYsmRwkCYLLQdM7QlMtpOT+0474GEx/ikLhy3Go1dmwkEv6sUKFwvGKAt2MTJsIyRL0AmOlsd7OyyP1EZRs5d88r5938/3V7/f9yiMMQAAgHa7PXpwcPBGUZRYsVgUdF33mabpRAjRbrf798jIyJ9utztkmqaTwOPxXHIcdyRJkjw7O7vJsqyJMQYURQEAAMAYAyqTyXzK5XJznU5neGpq6rsoivmZmZndQCBQYxgGggGr1Wo9KZVKfC6Xm8vn82IymdxaWlr6PDY29qtPqlarAcMwhnq9HoUQAgghgDHu73bcdo4QAhBCOpvNpnieV9bW1t4T3r3GjwFCCLRardFUKpVdWVn5eCPAQ53fVYH12zRNJpFIbMqyLP5XxncFQQiB4+Pj0Pz8/DeadNu6E5lg0LpNT1EUCIVCP5rNppe2K+wG5MyaxF1O7Yl6vd4mY51bO5HIN+bawiUcu0zsGo3GOG2PjDEGhmGwg6qy/xq7HmMM9vf3o8FgsHqjQQghUCgU4gsLC1/Inbhvuqw8gqurK5cgCHsnJyev+sRer0cdHh5GotFosV6vP7MaPyQAkVVVfS0Iwt7GxsZbhNC/ctbX19+JoihPT0/vViqVMISQtju2O7LKEEJa07QX6XT6qyiKcqVSCRM7CmMMTk9Pg8lkcisWiylnZ2cvGYaBHMcd8Txfmpyc/BkMBqt+v19jGAZijKnr6+vRi4uLp4qixLa3txPlcjni8XguFxcXM5IkySzLGv2Gkwbt7OxIy8vL6dXV1Q+NRmNcVdWwruu+8/Pz57VaLaBpmr/T6Qw7nU7T5XK13W73b47jjiKRSDkcDqsTExN1++RhjEG/VAghHY/HC91u1/GYZ+I+0KQUh8OBfD6fPmgc7XfAqr/tNQAAgL+sKC8+HBUOaAAAAABJRU5ErkJgggAA"/></td></tr></table></span><span><table border="0" cellspacing="0" cellpadding="0"><tr><td><img width="17" height="24" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAYCAYAAAAcYhYyAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACdUlEQVQ4jaXUT2jaUBwH8BebtDJFi7DOzTKlnbfQMe3K/LfDFDaGo7DeB7u1UHrqSa/bbYdSut0K3ieUVhGsIDIz1k6qO3iJ21othi4Murmk1CTm93apwdLVP+sX3uW95PP+8XsIY4z+p+3v7ztWV1cXMcbo3MDBwYE9mUw+7QeRJIkKBoMZDQEAxDCMd2Ji4pvP58urqkr0QlRVJXw+X14UxWtDe3t7W2tra4scx41bLJZfgiCYPB7PztjY2E/UI7u7uw+sViuPFEUZAgAEAMjj8XxkWdY5NTX1hWEYLwB0XU0sFnuxsrKypCNJUiUIAvE8f4OiKGVycvJ7Op1+nEgknsmyPNxtJX6/nykWiy5NzeVyDxcWFt72mr2zybJMhkKhbV1b5TjO5nK5igRB9DoKLSRJtiRJGtGQo6Ojm3a7vda3cBYA0GnI4eHhbYfDUR0UMZvNDQ2p1+vjNpuNGxTR6/VNDWk2m3qKopRBEUVRKA2hKErBGPd/qmeRZXlYQ4xGo3hycmK4EmIymf40Gg3zlRCapsuFQuH+IIAoisZzt0PTdDmbzT7CGPeNlEqlezRNlzXE6XR+LZfLNADouv3YDsYYbW5uzgYCgbxWBwCAwuHwVr1ev9VP3bRaLd3MzMyOJEnUuYFMJhOcn59/16sIAQDF4/HnkUjk1YXn8fT0dMTv93+oVCp3uiGCIBimp6c/8zx//QKCMUYsyzrdbndBEATDZeU/Nzf3fmNjY7bd98+ZUqnUE7fbXSiVSnfbWwMAxLKsMxQKba+vr7/s3DJx2ZVWq1V7NBp9XavV7Far9cfx8bFldHT09/Ly8huv1/up89u/dq5kKfBhVZEAAAAASUVORK5CYIIA"/></td></tr></table></span><span><table border="0" cellspacing="0" cellpadding="0"><tr><td><img width="24" height="16" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAQCAYAAAAMJL+VAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACWUlEQVQ4jbVUz4tSURS+972C9PmjZJ5QgyIIEkkLe0/mBUptQlu4UFoERjDMRlwM7UcGof4BW4ibSAxmJbkYmGFwIYGMQj5dyAxTQxBFCukI+XoqvOc9LYYn8yspywOHy/3u5XznnPudiwEAIYRQv983iqLI1Wo1vl6v32m329cBgAIApNfrBxaLpTccDnWDwUA/Go2ujMdjmmEY2ePxNLxe7/tAILBjMBhkLR7G+HhNJpPrxWLxgdFolDiOEzmOE3mery0uLn6jKOr49gUGAEiWZabRaHiq1apQKBTCPM/XVldXXzqdzk8aAer1elcJIQgAJn52f5ETQk7dI4SgUql0z+/3v0un0zHtDGslnc1uksGUCk62QjNVVelEIvFiOBzqUqnUs/9OoOHLy8uvQ6HQ5twIZFlmQqHQJjU1yj8YwzAyTdPjuREghJCqqpfmRtDtdhcwxufld3R0dO2kzP5UpmfxaDT6Znt7O3CqAlmW9bFYLGOz2b7OmrmiKJdXVlZeORyOz8FgcAcBADo8PHSura09FwRhd2Nj4/Esg6YoCp3L5Z4IgrCbzWafajgGAFQqle5HIpG3Lpfrg06nG7nd7j2O40S3273HsmyHZdmOwWD4qUmSEIIlSTK2Wq0blUrlbrlc9jWbzdvhcLgQj8fTZrP5x+Qv0nS7tbX1MJ/PP8pkMrH9/f1boihyBwcHNzudDtvtdhckSTICAMYYA8YYTCZT32q1fhcEoerz+coul+sjRVFwbj60UlRVpZaWliqKotCztOh3+OSRaZomdrv9CwBMH+G/tF8GFPsngvE2rQAAAABJRU5ErkJgggAA"/></td></tr></table></span></p><p class="s22" style="text-indent: 0pt;text-align: right;"><span class="s28">id</span>F <span class="s29">(</span>C<span class="s29">)</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: center;">id<i>A</i><i>                          </i>F(f)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s22" style="text-indent: 0pt;text-align: right;"><span class="s28">= id</span>F <span class="s29">(</span>B<span class="s29">)</span></p><p style="padding-top: 6pt;text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 47pt;text-indent: 0pt;text-align: justify;">In this diagram:</p></li><li data-list-text="•"><p style="padding-top: 5pt;padding-left: 72pt;text-indent: -9pt;line-height: 14pt;text-align: left;">Objects <i>A </i>and <i>B </i>in category <span class="s10">C </span>are mapped to object <i>F </i>(<i>X</i>) in category</p><p style="padding-left: 72pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s10">D</span>, where <i>X </i>= <span class="s10">{</span><i>A, B</i><span class="s10">}</span>; hence, <i>F </i>(<i>A</i>) = <i>F </i>(<i>B</i>).</p></li><li data-list-text="•"><p style="padding-top: 3pt;padding-left: 72pt;text-indent: -9pt;text-align: left;">Objects <i>C </i>in category <span class="s10">C </span>is mapped to object <i>F </i>(<i>C</i>) in category <span class="s10">D</span>.</p></li><li data-list-text="•"><p style="padding-top: 3pt;padding-left: 72pt;text-indent: -9pt;line-height: 14pt;text-align: left;">The morphism <i>g </i>: <i>C </i><span class="s10">→ </span><i>B </i>in <span class="s10">C </span>is mapped to the morphism <i>F </i>(<i>g</i>) : <i>F </i>(<i>C</i>) <span class="s10">→</span></p><p style="padding-left: 72pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><i>F </i>(<i>B</i>) in <span class="s10">D</span>.</p></li><li data-list-text="•"><p style="padding-top: 6pt;padding-left: 72pt;text-indent: -10pt;line-height: 78%;text-align: left;">Morphism <i>f </i>in <span class="s10">C </span>is mapped to morphism <i>F </i>(<i>f </i>) in <span class="s10">D</span>, where its domain and codomain are the same (note: <i>F </i>(<i>f </i>) <span class="s10"≯</span>= id).</p></li><li data-list-text="•"><p style="padding-top: 4pt;padding-left: 72pt;text-indent: -9pt;line-height: 14pt;text-align: left;">Identity morphisms id<i>A</i><i> </i>and id<i>B</i><i> </i>in <span class="s10">C </span>map to same identity morphism in</p></li></ul><p class="s22" style="padding-left: 72pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s30">D</span><span class="s28">: id</span>F <span class="s29">(</span>A<span class="s29">) </span><span class="s31">= id</span>F <span class="s29">(</span>B<span class="s29">)</span></p><p style="padding-top: 4pt;text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2.2.4"><h3 style="padding-left: 82pt;text-indent: -34pt;text-align: left;">Functors in Haskell</h3><p style="padding-top: 6pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">In Haskell, the concept of a functor is captured by the <span class="s6">Functor </span>type class. A type constructor <i>F </i>is a functor if it defines a <span class="s16">fmap </span>function that maps func- tions over the wrapped values while preserving the identity and composition properties.</p><ul id="l25"><li data-list-text="•"><p class="s9" style="padding-top: 6pt;padding-left: 72pt;text-indent: -9pt;text-align: left;">Type Class Definition<span class="p">:</span></p><p class="s6" style="padding-top: 5pt;padding-left: 64pt;text-indent: 0pt;text-align: left;"><span class="s32">1       </span>class Functor <span style=" color: #000;">f </span>where</p><p class="s32" style="padding-left: 64pt;text-indent: 0pt;text-align: left;">2            <span class="s16">fmap :: ( a -&gt; b) -&gt; f a -&gt; f b</span></p><p style="padding-top: 1pt;text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="•"><p class="s9" style="padding-left: 72pt;text-indent: -9pt;text-align: left;">Preservation of Identity <span class="p">:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 72pt;text-indent: 0pt;text-align: left;">For any type <i>f </i>, the following should hold:</p><p class="s16" style="padding-top: 5pt;padding-left: 64pt;text-indent: 0pt;text-align: left;"><span class="s32">1        </span>fmap <span style=" color: #00F;">id </span>= <span style=" color: #00F;">id</span></p><p style="padding-top: 1pt;text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="•"><p class="s9" style="padding-left: 72pt;text-indent: -9pt;text-align: left;">Preservation of Composition<span class="p">:</span></p></li></ul><p class="s9" style="padding-top: 10pt;padding-left: 72pt;text-indent: 0pt;text-align: left;"><span class="p">For any functions </span>g <span class="p">: </span>a <span class="s10">→ </span>b <span class="p">and </span>h <span class="p">: </span>b <span class="s10">→ </span>c<span class="p">, the following should hold:</span></p><p class="s32" style="padding-top: 3pt;padding-left: 64pt;text-indent: 0pt;text-align: left;">1        <span class="s16">fmap ( h . g) = fmap h . fmap g</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2.2.5"><h3 style="padding-left: 82pt;text-indent: -34pt;text-align: left;">Example: <span class="s6">Maybe </span>Functor in Haskell</h3><p style="padding-top: 6pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">Consider the <span class="s6">Maybe </span>type in Haskell:</p><ul id="l26"><li data-list-text="•"><p style="padding-top: 6pt;padding-left: 72pt;text-indent: -10pt;text-align: justify;"><i>Object Mapping </i>: The type constructor <span class="s6">Maybe </span>maps a type <span class="s16">a </span>to the type <span class="s6">Maybe </span><span class="s16">a</span>, which can represent either a value of type <span class="s16">a </span>(<span class="s6">Just </span><span class="s16">a</span>) or nothing (<span class="s6">Nothing</span>).</p></li><li data-list-text="•"><p style="padding-top: 7pt;padding-left: 72pt;text-indent: -10pt;text-align: justify;"><i>Morphism Mapping </i>: The <span class="s16">fmap </span>function for <span class="s6">Maybe </span>applies a function to the value inside a <span class="s6">Just</span>, or leaves <span class="s6">Nothing </span>unchanged:</p></li></ul><p class="s32" style="padding-top: 5pt;padding-left: 64pt;text-indent: 0pt;text-align: left;">1        <span class="s6">instance Functor Maybe where</span></p><p class="s16" style="padding-left: 64pt;text-indent: 0pt;text-align: left;"><span class="s32">2           </span>fmap _ <span style=" color: #00F;">Nothing  </span>= <span style=" color: #00F;">Nothing</span></p><p class="s16" style="padding-left: 64pt;text-indent: 0pt;text-align: left;"><span class="s32">3            </span>fmap f ( <span style=" color: #00F;">Just </span>x) = <span style=" color: #00F;">Just </span>( f x)</p><p style="padding-top: 11pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">The <span class="s6">Maybe </span>functor satisfies the identity and composition properties, making it a valid instance of the <span class="s6">Functor </span>type class in Haskell.</p><p style="padding-left: 47pt;text-indent: 14pt;text-align: justify;">In summary, functors in category theory provide a powerful abstraction for mapping between categories, preserving their structure. In Haskell, functors are a central concept for handling computations that can be mapped over, enabling flexible and modular code design.</p><p style="padding-top: 1pt;text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li data-list-text="2.3"><h2 style="padding-left: 78pt;text-indent: -30pt;text-align: left;">Natural Transformations</h2><p style="padding-top: 5pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">Natural transformations are a fundamental concept in category theory, pro- viding a way to relate functors. While functors map objects and morphisms between categories, natural transformations offer a way to compare functors that act on the same categories, preserving the structure of the category.</p><p style="padding-top: 1pt;text-indent: 0pt;text-align: left;"><br/></p><ol id="l27"><li data-list-text="2.3.1"><h3 style="padding-left: 82pt;text-indent: -34pt;text-align: left;">Definition of a Natural Transformation</h3><p style="padding-top: 7pt;padding-left: 47pt;text-indent: 0pt;line-height: 78%;text-align: justify;">Given two functors <i>F </i>and <i>G </i>from a category <span class="s10">C </span>to a category <span class="s10">D</span>, a <i>natural transformation η </i>from <i>F </i>to <i>G</i>, denoted as <i>η </i>: <i>F </i><span class="s10">⇒ </span><i>G</i>, consists of a collection of morphisms in <span class="s10">D</span>. Specifically, for each object <i>X </i>in <span class="s10">C</span>, there is a morphism <i>η</i><i>X</i><i> </i>: <i>F </i>(<i>X</i>) <span class="s10">→ </span><i>G</i>(<i>X</i>) in <span class="s10">D </span>such that the following <i>naturality condition </i>is satisfied:</p><p class="s9" style="padding-top: 10pt;padding-left: 47pt;text-indent: 0pt;line-height: 86%;text-align: justify;">Naturality Condition: <span class="p">For every morphism </span>f <span class="p">: </span>X <span class="s10">→ </span>Y <span class="p">in </span><span class="s10">C</span><span class="p">, the following diagram commutes:</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s9" style="padding-top: 7pt;text-indent: 0pt;text-align: right;">F <span class="p">(</span>X<span class="p">)</span></p><p class="s22" style="padding-top: 2pt;padding-left: 22pt;text-indent: 0pt;text-align: left;">F <span class="s29">(</span>f <span class="s29">)</span></p><p class="s9" style="padding-top: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;"><span class="s33">¸</span><span class="s34">/ </span>F <span class="p">(</span>Y <span class="p">)</span></p><p style="padding-top: 6pt;text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p class="s21" style="text-indent: 0pt;line-height: 11pt;text-align: right;"> <span class="s20"> </span></p><p class="s9" style="text-indent: 0pt;line-height: 11pt;text-align: right;">G<span class="p">(</span>X</p><p class="s22" style="padding-top: 3pt;text-indent: 0pt;text-align: left;">η<span class="s35">X</span>          η<span class="s35">Y</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p class="s20" style="text-indent: 0pt;line-height: 10pt;text-align: left;">/<span class="s21">¸</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s22" style="padding-left: 34pt;text-indent: 0pt;line-height: 6pt;text-align: left;">G<span class="s29">(</span>f <span class="s29">)</span><span class="s23"> </span></p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 6pt;text-indent: 0pt;line-height: 10pt;text-align: left;">)       <i>G</i>(<i>Y </i>)</p><p style="padding-top: 6pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">This commutative diagram means that applying the natural transformation <i>η </i>after the functor <i>F </i>is equivalent to applying the functor <i>G </i>after the natural transformation <i>η</i>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2.3.2"><h3 style="padding-left: 82pt;text-indent: -34pt;text-align: left;">Intuition Behind Natural Transformations</h3><p style="padding-top: 6pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">To understand the intuition, think of functors as ”translators” that convert ob- jects and morphisms from one category into another. A natural transformation then provides a consistent way to translate the results of one functor into an- other, ensuring that the translation behaves well with respect to the structure of the categories involved.</p><p style="padding-left: 47pt;text-indent: 14pt;text-align: justify;">In other words, a natural transformation can be seen as a ”smooth transi- tion” from one functor to another, where the translation between the functors is coherent with the underlying morphisms of the categories.</p><p style="padding-top: 2pt;text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2.3.3"><h3 style="padding-left: 82pt;text-indent: -34pt;text-align: left;">Example: Natural Transformation Between Functors on Set</h3><p style="padding-top: 5pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">Consider the category <span class="h3">Set </span>and two functors <i>F, G </i>: <span class="h3">Set </span><span class="s10">→ </span><span class="h3">Set</span>.</p><ul id="l28"><li data-list-text="•"><p class="s9" style="padding-top: 4pt;padding-left: 72pt;text-indent: -9pt;text-align: justify;"><span class="p">Let </span>F <span class="p">(</span>X<span class="p">) = </span>X <span class="s10">× </span>X<span class="p">, the Cartesian product of </span>X <span class="p">with itself.</span></p></li><li data-list-text="•"><p style="padding-top: 4pt;padding-left: 72pt;text-indent: -9pt;text-align: justify;">Let <i>G</i>(<i>X</i>) = <span class="s10">P</span>(<i>X</i>), the power set of <i>X</i>.</p></li></ul><p class="s9" style="padding-top: 6pt;padding-left: 47pt;text-indent: 0pt;line-height: 82%;text-align: justify;"><span class="p">A natural transformation </span>η <span class="p">: </span>F <span class="s10">⇒ </span>G <span class="p">could map each pair (</span>x<span class="s17">1</span>, x<span class="s17">2</span><span class="p">) </span><span class="s10">∈ </span>X <span class="s10">× </span>X <span class="p">to the subset </span><span class="s10">{</span>x<span class="s17">1</span>, x<span class="s17">2</span><span class="s10">} </span><span class="p">in </span><span class="s10">P</span><span class="p">(</span>X<span class="p">), providing a coherent way to relate the Cartesian product functor to the power set functor.</span></p><p style="padding-top: 3pt;text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2.3.4"><h3 style="padding-left: 82pt;text-indent: -34pt;text-align: left;">Natural Transformations in Haskell</h3><p style="padding-top: 6pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">In Haskell, natural transformations can be understood as polymorphic func- tions that transform one functor into another while preserving the functorial structure. Consider two functors <span class="s16">F </span>and <span class="s16">G</span>:</p><p class="s32" style="padding-top: 5pt;padding-left: 93pt;text-indent: -53pt;text-align: left;">1    <span class="s6">type </span><span class="s16">NaturalTransformation f g = forall a. f a -&gt; g a</span></p><p style="padding-top: 6pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">This type signature indicates that a natural transformation is a function that, for any type <span class="s16">a</span>, transforms a value of type <span class="s16">f a </span>into a value of type <span class="s16">g a</span>.</p><p style="padding-top: 2pt;text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2.3.5"><h3 style="padding-left: 82pt;text-indent: -34pt;text-align: left;">Example: Maybe to List Natural Transformation</h3><p style="padding-top: 6pt;padding-left: 47pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">Consider the functors <span class="s6">Maybe </span>and <span class="s16">[] </span>(the list functor). A natural transformation</p><p style="padding-left: 47pt;text-indent: 0pt;line-height: 15pt;text-align: justify;"><i>η </i>: Maybe <span class="s10">⇒ </span>[] can be defined as follows:</p><p class="s6" style="padding-top: 4pt;padding-left: 39pt;text-indent: 0pt;text-align: left;"><span class="s32">1    </span>maybe To List <span style=" color: #000;">:: </span>Maybe <span style=" color: #000;">a -&gt; [ a]</span></p><p class="s32" style="padding-left: 39pt;text-indent: 0pt;text-align: left;">2    <span class="s6">maybe To List Nothing  </span><span class="s16">= []</span></p><p class="s6" style="padding-left: 39pt;text-indent: 0pt;text-align: left;"><span class="s32">3    </span>maybe To List <span style=" color: #000;">( </span>Just <span style=" color: #000;">x) = [ x]</span></p><p style="padding-top: 6pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">This function provides a way to convert a <span class="s6">Maybe </span><span class="s16">a </span>value into a list <span class="s16">[a]</span>, pre- serving the structure in the sense that it provides a consistent translation across all types <span class="s16">a</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2.3.6"><h3 style="padding-left: 82pt;text-indent: -34pt;text-align: left;">Visualizing the Example</h3><p style="padding-top: 6pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">For any type <span class="s16">a</span>, the following commutative diagram illustrates the naturality condition:</p><p style="text-indent: 0pt;line-height: 15pt;text-align: center;">Maybe a <span class="s36">&nbsp;&nbsp;&nbsp; </span><span class="s37">Maybe f &nbsp;&nbsp; </span><span class="s33">¸</span><span class="s34">/ </span>Maybe b</p><p style="padding-top: 6pt;text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">Where:</p><p class="s38" style="padding-top: 3pt;padding-left: 56pt;text-indent: 0pt;text-align: left;">η<span class="s39">a</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p class="s27" style="padding-left: 53pt;text-indent: 0pt;line-height: 6pt;text-align: left;">    <span class="s29">map f</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 88pt;text-indent: 0pt;line-height: 10pt;text-align: center;">[<i>a</i>]</p><p class="s22" style="padding-top: 3pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">η<span class="s35">b</span></p><p style="padding-top: 5pt;text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p class="s20" style="padding-left: 39pt;text-indent: 0pt;line-height: 10pt;text-align: left;"> <span class="s21"> </span></p><p style="padding-left: 31pt;text-indent: 0pt;line-height: 13pt;text-align: left;"><span class="s33">¸</span><span class="s34">/ </span>[<i>b</i>]</p><ul id="l29"><li data-list-text="•"><p class="s16" style="padding-top: 8pt;padding-left: 72pt;text-indent: -9pt;text-align: left;">f: a -&gt; b <span class="p">is a function in Haskell.</span></p></li><li data-list-text="•"><p style="padding-top: 7pt;padding-left: 72pt;text-indent: -9pt;text-align: left;"><span class="s6">Maybe </span><span class="s16">f </span>applies <span class="s16">f </span>inside the <span class="s6">Maybe</span>.</p></li><li data-list-text="•"><p class="s16" style="padding-top: 7pt;padding-left: 72pt;text-indent: -9pt;text-align: left;"><span style=" color: #00F;">map </span>f <span class="p">applies </span>f <span class="p">to each element of the list.</span></p></li></ul><p style="padding-top: 7pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">This diagram shows that transforming the <span class="s6">Maybe </span>value before or after applying the function <span class="s16">f </span>gives the same result, satisfying the naturality condition.</p><p style="padding-top: 2pt;text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2.3.7"><h3 style="padding-left: 82pt;text-indent: -34pt;text-align: left;">Summary</h3><p style="padding-top: 6pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">Natural transformations are a powerful tool in category theory, providing a structured way to compare functors. In Haskell, they allow us to define transfor- mations between functors that maintain the structure and relationships defined by the original categories. This concept is foundational in functional program- ming, enabling the creation of modular and reusable code.</p><p style="padding-top: 5pt;text-indent: 0pt;text-align: left;"><br/></p></li></ol></li></ol></li><li data-list-text="3"><h1 style="padding-left: 71pt;text-indent: -24pt;text-align: left;">Advanced Concept: Monads</h1><ol id="l30"><li data-list-text="3.1"><h2 style="padding-top: 8pt;padding-left: 78pt;text-indent: -30pt;text-align: left;">Monads</h2><p style="padding-top: 5pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">Monads are a central concept in both category theory and functional program- ming, particularly in Haskell. They provide a way to model computations as a series of steps, encapsulating values along with their context, such as computa- tions that might involve side effects, state, or potential failure [4]. In category theory, a monad can be understood as a specific kind of functor with additional structure that allows chaining of operations in a consistent manner.</p><p style="padding-top: 2pt;text-indent: 0pt;text-align: left;"><br/></p><ol id="l31"><li data-list-text="3.1.1"><h3 style="padding-left: 82pt;text-indent: -34pt;text-align: left;">Definition of a Monad</h3><p style="padding-top: 6pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">Formally, a <i>monad </i>in category theory is a triple (<i>T, η, µ</i>), where:</p><ol id="l32"><li data-list-text="1"><p style="padding-top: 8pt;padding-left: 72pt;text-indent: -9pt;text-align: left;"><i>Endofunctor T </i>: <span class="s10">C → C</span>:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ul id="l33"><li data-list-text="•"><p style="padding-left: 94pt;text-indent: -10pt;line-height: 82%;text-align: justify;">This is a functor that maps a category <span class="s10">C </span>to itself. It takes objects and morphisms in <span class="s10">C </span>and maps them to objects and morphisms in the same category. The endofunctor <i>T </i>represents the underlying type</p><p style="padding-left: 94pt;text-indent: 0pt;text-align: justify;">constructor or context in the monad.</p></li></ul></li><li data-list-text="2"><p class="s9" style="padding-top: 6pt;padding-left: 72pt;text-indent: -9pt;text-align: justify;">Natural Transformation (Unit) η <span class="p">: id</span><span class="s11">C</span><span class="s40"> </span><span class="s10">⇒ </span>T <span class="p">:</span></p><ul id="l34"><li data-list-text="•"><p style="padding-top: 6pt;padding-left: 94pt;text-indent: -10pt;line-height: 91%;text-align: justify;">This is a natural transformation from the identity functor id<span class="s11">C</span><span class="s40"> </span>to the functor <i>T </i>. It maps each object <i>X </i>in <span class="s10">C </span>to a morphism <i>η</i><i>X</i><i> </i>: <i>X </i><span class="s10">→ </span><i>T </i>(<i>X</i>). This natural transformation is called the <i>unit </i>(or <span class="s6">return </span>in programming), and it provides a way to embed or ”lift” an object from <span class="s10">C </span>into the monadic context <i>T </i>.</p></li></ul></li><li data-list-text="3"><p class="s9" style="padding-top: 4pt;padding-left: 72pt;text-indent: -9pt;text-align: justify;">Natural Transformation (Multiplication) µ <span class="p">: </span>T <span class="s41">2</span><span class="p"> </span><span class="s10">⇒ </span>T <span class="p">:</span></p><ul id="l35"><li data-list-text="•"><p class="s9" style="padding-top: 6pt;padding-left: 94pt;text-indent: -10pt;line-height: 80%;text-align: justify;"><span class="p">This is a natural transformation from the functor composition </span>T <span class="s10">◦ </span>T <span class="p">(denoted as </span>T <span class="s41">2</span><span class="p">) to the functor </span>T <span class="p">. For each object </span>X <span class="p">in </span><span class="s10">C</span><span class="p">, it provides a morphism </span>µ<span class="s12">X</span> <span class="p">: </span>T <span class="p">(</span>T <span class="p">(</span>X<span class="p">)) </span><span class="s10">→ </span>T <span class="p">(</span>X<span class="p">), which ”flattens” a nested monadic structure (like </span>T <span class="p">(</span>T <span class="p">(</span>X<span class="p">))) into a single layer (</span>T <span class="p">(</span>X<span class="p">)). This operation</span></p></li></ul></li></ol><p style="padding-left: 94pt;text-indent: 0pt;text-align: justify;">is known as <i>multiplication </i>(or <span class="s6">join </span>in programming).</p><p style="padding-top: 10pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">These components must satisfy two coherence conditions, known as the <i>unit laws </i>and the <i>associativity law </i>:</p><ol id="l36"><li data-list-text="1"><p class="s9" style="padding-top: 9pt;padding-left: 72pt;text-indent: -9pt;line-height: 11pt;text-align: left;">Left Unit Law <span class="p">: The following diagram must commute for all objects </span>X <span class="p">in</span></p><p class="s10" style="padding-left: 72pt;text-indent: 0pt;line-height: 11pt;text-align: left;">C<span class="p">:</span></p><p class="s9" style="padding-left: 24pt;text-indent: 0pt;line-height: 17pt;text-align: center;">T <span class="p">(</span>X<span class="p">) </span><span class="s42">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class="s43">η</span><span class="s44">T </span><span class="s45">(</span><span class="s46">X</span><span class="s45">) &nbsp;&nbsp;&nbsp;&nbsp; </span><span class="s34">/</span><span class="s33">¸ </span>T <span class="p">(</span>T <span class="p">(</span>X<span class="p">))</span></p><p style="padding-top: 6pt;text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p class="s20" style="text-indent: 0pt;line-height: 12pt;text-align: right;"> <span class="s21"> </span></p><p class="s9" style="text-indent: 0pt;line-height: 11pt;text-align: right;">T <span class="p">(</span>X</p><p class="s48" style="padding-top: 3pt;padding-left: 88pt;text-indent: 0pt;text-align: center;"><span class="s47">id</span>T <span class="s49">(</span>X<span class="s49">)          </span><span class="s38">µ</span><span class="s39">X</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p class="s20" style="text-indent: 0pt;line-height: 10pt;text-align: left;">/<span class="s21">¸</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s48" style="padding-left: 34pt;text-indent: 0pt;line-height: 7pt;text-align: left;"><span class="s47">id</span>T <span class="s49">(</span>X<span class="s49">)</span><span class="s27"> </span></p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 88pt;text-indent: 0pt;line-height: 10pt;text-align: center;">)        <i>T </i>(<i>X</i>)</p><p style="padding-top: 7pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">This law ensures that applying the unit <i>η </i>followed by the multiplication</p><p class="s9" style="padding-left: 72pt;text-indent: 0pt;text-align: left;">µ <span class="p">is the same as doing nothing (i.e., applying the identity).</span></p></li><li data-list-text="2"><p class="s9" style="padding-top: 8pt;padding-left: 24pt;text-indent: -9pt;line-height: 11pt;text-align: center;">Right Unit Law <span class="p">: The following diagram must also commute for all objects</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 72pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><i>X </i>in <span class="s10">C</span>:</p><p class="s9" style="padding-top: 3pt;text-indent: 0pt;text-align: right;">T <span class="p">(</span>X<span class="p">)</span></p><p class="s9" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;"><span class="s50">T </span><span class="s51">(</span><span class="s50">η</span><span class="s52">X </span><span class="s51">)  </span><span class="s34">/</span><span class="s33">¸ </span>T <span class="p">(</span>T <span class="p">(</span>X<span class="p">))</span></p><p style="padding-top: 6pt;text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p class="s20" style="text-indent: 0pt;line-height: 12pt;text-align: right;"> <span class="s21"> </span></p><p class="s9" style="text-indent: 0pt;line-height: 11pt;text-align: right;">T <span class="p">(</span>X</p><p class="s48" style="padding-top: 3pt;text-indent: 0pt;text-align: left;"><span class="s47">id</span>T <span class="s49">(</span>X<span class="s49">)</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s48" style="padding-left: 34pt;text-indent: 0pt;line-height: 7pt;text-align: left;"><span class="s47">id</span>T <span class="s49">(</span>X<span class="s49">)</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 6pt;text-indent: 0pt;line-height: 10pt;text-align: left;">)</p><p class="s22" style="padding-top: 3pt;padding-left: 38pt;text-indent: 0pt;text-align: left;">µ<span class="s35">X</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p class="s20" style="padding-left: 35pt;text-indent: 0pt;line-height: 10pt;text-align: left;"> <span class="s21"> </span></p><p class="s9" style="padding-left: 20pt;text-indent: 0pt;line-height: 13pt;text-align: left;"><span class="s33">¸</span><span class="s34">/ </span>T <span class="p">(</span>X<span class="p">)</span></p><p style="padding-top: 7pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">This law ensures that applying the functor to the unit and then the mul- tiplication is equivalent to doing nothing.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3"><p class="s9" style="padding-left: 24pt;text-indent: -9pt;line-height: 11pt;text-align: center;">Associativity Law <span class="p">: The following diagram must commute for all objects</span></p></li></ol><p style="padding-left: 72pt;text-indent: 0pt;line-height: 13pt;text-align: left;"><i>X </i>in <span class="s10">C</span>:</p><p class="s9" style="padding-left: 24pt;text-indent: 0pt;line-height: 16pt;text-align: center;">T <span class="p">(</span>T <span class="p">(</span>T <span class="p">(</span>X<span class="p">))) </span><span class="s36">&nbsp;&nbsp;&nbsp; </span><span class="s53">T </span><span class="s37">(</span><span class="s53">µ</span><span class="s44">X </span><span class="s37">) &nbsp;&nbsp;&nbsp;&nbsp; </span><span class="s33">¸</span><span class="s34">/ </span>T <span class="p">(</span>T <span class="p">(</span>X<span class="p">))</span></p><p style="padding-top: 6pt;text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p class="s49" style="padding-top: 3pt;padding-left: 182pt;text-indent: 0pt;text-align: left;"><span class="s38">µ</span><i>T </i>(<i>X</i>)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s20" style="padding-left: 179pt;text-indent: 0pt;line-height: 46%;text-align: left;">     <span class="s54">µ</span><span class="s55">X</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s9" style="padding-left: 160pt;text-indent: 0pt;line-height: 10pt;text-align: left;">T <span class="p">(</span>T <span class="p">(</span>X<span class="p">))</span></p><p class="s22" style="padding-top: 4pt;padding-left: 52pt;text-indent: 0pt;text-align: left;">µ<span class="s35">X</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p class="s20" style="padding-left: 49pt;text-indent: 0pt;line-height: 10pt;text-align: left;"> <span class="s21"> </span></p><p class="s9" style="padding-left: 34pt;text-indent: 0pt;line-height: 13pt;text-align: left;"><span class="s33">¸</span><span class="s34">/ </span>T <span class="p">(</span>X<span class="p">)</span></p><p style="padding-top: 6pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">This law ensures that the order in which you apply multiplication does not matter; both paths yield the same result.</p><p style="padding-top: 8pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">These laws guarantee that the operations within a monad are associative and that the unit acts as a neutral element, allowing monads to effectively manage the sequencing of computations.</p><p style="padding-top: 2pt;text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3.1.2"><h3 style="padding-left: 82pt;text-indent: -34pt;text-align: left;">Monads in Haskell</h3><p style="padding-top: 6pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">In Haskell, a monad is defined by the <span class="s6">Monad </span>type class, which provides the <span class="s6">return </span>and <span class="s16">bind </span>(<span class="s16">&gt;&gt;=</span>) operations that correspond to the unit and multiplica- tion in the categorical definition [2]. The Haskell <span class="s6">Monad </span>type class is defined as:</p><p class="s6" style="padding-top: 5pt;padding-left: 39pt;text-indent: 0pt;text-align: left;"><span class="s32">1    </span>class <span style=" color: #000;">Applicative m </span>=&gt; Monad <span style=" color: #000;">m </span>where</p><p class="s32" style="padding-left: 39pt;text-indent: 0pt;text-align: left;">2        <span class="s6">return </span><span class="s16">:: a -&gt; m a</span></p><p class="s32" style="padding-left: 39pt;text-indent: 0pt;text-align: left;">3        <span class="s16">( &gt; &gt;=)  :: m a -&gt; ( a -&gt; m b) -&gt; m b</span></p><p style="padding-top: 1pt;text-indent: 0pt;text-align: left;"><br/></p><ul id="l37"><li data-list-text="•"><p style="padding-left: 72pt;text-indent: -9pt;text-align: left;"><span class="s6">return </span>corresponds to the unit <i>η </i>and lifts a value into the monadic context</p></li><li data-list-text="•"><p style="padding-top: 6pt;padding-left: 72pt;text-indent: -10pt;text-align: justify;"><span class="s16">&gt;&gt;= </span>(<span class="s16">bind</span>) corresponds to the multiplication <i>µ </i>and sequences computa- tions by taking a monadic value and a function that returns a monad, then applying the function and flattening the result.</p></li></ul><p style="padding-top: 2pt;text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3.1.3"><h3 style="padding-left: 82pt;text-indent: -34pt;text-align: left;">Example: The <span class="s6">Maybe </span>Monad</h3><p style="padding-top: 6pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">The <span class="s6">Maybe </span>monad is used to represent computations that may fail. In the <span class="s6">Maybe</span></p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">monad:</p><ul id="l38"><li data-list-text="•"><p class="s6" style="padding-top: 8pt;padding-left: 72pt;text-indent: -9pt;text-align: left;">return <span class="p">is simply </span>Just<span class="p">, which injects a value into the monadic context.</span></p></li><li data-list-text="•"><p style="padding-top: 6pt;padding-left: 72pt;text-indent: -9pt;line-height: 12pt;text-align: left;"><span class="s16">&gt;&gt;= </span>applies a function to the value inside a <span class="s6">Just</span>, or passes through</p></li></ul><p class="s6" style="padding-left: 72pt;text-indent: 0pt;line-height: 12pt;text-align: left;">Nothing <span class="p">unchanged.</span></p><p style="padding-top: 8pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">The <span class="s6">Maybe </span>monad can be defined as:</p><p class="s32" style="padding-top: 5pt;padding-left: 39pt;text-indent: 0pt;text-align: left;">1    <span class="s6">instance Monad Maybe where</span></p><p class="s6" style="padding-left: 39pt;text-indent: 0pt;text-align: left;"><span class="s32">2        </span>return <span style=" color: #000;">x = </span>Just <span style=" color: #000;">x</span></p><p class="s6" style="padding-left: 39pt;text-indent: 0pt;text-align: left;"><span class="s32">3       </span>Nothing <span style=" color: #000;">&gt;&gt;= _ = </span>Nothing</p><p class="s32" style="padding-left: 39pt;text-indent: 0pt;text-align: left;">4        <span class="s6">Just </span><span class="s16">x  &gt;&gt;= f = f x</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">This definition satisfies the monad laws, ensuring that computations within the</p><p class="s6" style="padding-left: 47pt;text-indent: 0pt;text-align: left;">Maybe <span class="p">monad are consistently chained and manage potential failures gracefully.</span></p><p style="padding-top: 2pt;text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3.1.4"><h3 style="padding-left: 82pt;text-indent: -34pt;text-align: left;">Visualizing the Monad Laws</h3><ol id="l39"><li data-list-text="1"><p class="s9" style="padding-top: 6pt;padding-left: 72pt;text-indent: -9pt;text-align: left;">Left Unit Law:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 6pt;text-indent: 0pt;text-align: right;">Just x</p><p style="padding-top: 11pt;text-indent: 0pt;text-align: left;"><br/></p><p class="s29" style="text-indent: 0pt;text-align: right;">id</p><p style="padding-top: 2pt;padding-left: 36pt;text-indent: 0pt;text-align: left;"><span class="s41">return</span>  <span class="s34">/</span><span class="s33">¸ </span>Just(Just x)</p><p style="padding-top: 9pt;text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"/><p class="s22" style="text-indent: 0pt;text-align: center;">µ</p><p class="s56" style="text-indent: 0pt;line-height: 10pt;text-align: left;"><span class="s26">id &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>/<span class="s57">¸</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s21" style="padding-top: 10pt;padding-left: 11pt;text-indent: 0pt;line-height: 12pt;text-align: center;">       <span class="s58">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</span><span class="s59">                                      </span> </p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 11pt;text-align: center;">Just x          Just x</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2"><p class="s9" style="padding-top: 3pt;padding-left: 72pt;text-indent: -9pt;text-align: left;">Right Unit Law:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 4pt;text-indent: 0pt;text-align: left;">Just x</p><p style="padding-top: 11pt;text-indent: 0pt;text-align: left;"><br/></p><p class="s29" style="padding-left: 20pt;text-indent: 0pt;text-align: left;">id</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s29" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">Just <span class="s60">◦ </span>return <span class="s56">/</span><span class="s57">¸ </span><span class="s61">Just(Just x)</span></p><p style="padding-top: 9pt;text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"/><p class="s22" style="text-indent: 0pt;text-align: center;">µ</p><p class="s57" style="text-indent: 0pt;line-height: 10pt;text-align: left;"><span class="s26">id &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>¸<span class="s56">/</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s20" style="padding-top: 10pt;padding-left: 11pt;text-indent: 0pt;line-height: 12pt;text-align: center;">       <span class="s58">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</span><span class="s59">                                      </span><span class="s21"> </span></p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 11pt;text-align: center;">Just x          Just x</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3"><p class="s9" style="padding-top: 3pt;padding-left: 72pt;text-indent: -9pt;text-align: left;">Associativity Law:</p></li></ol><p style="padding-top: 4pt;text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 132pt;text-indent: 0pt;text-align: left;">Just(Just(Just x))</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s29" style="padding-left: 9pt;text-indent: 0pt;text-align: left;">Just <span class="s60">◦ </span><i>µ</i></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p class="s33" style="padding-left: 20pt;text-indent: 0pt;text-align: left;">¸<span class="s34">/ </span><span class="p">Just(Just x)</span></p><p style="padding-top: 6pt;text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p class="s22" style="padding-top: 3pt;padding-left: 175pt;text-indent: 0pt;text-align: left;">µ</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s20" style="padding-left: 172pt;text-indent: 0pt;line-height: 6pt;text-align: left;">       <span class="s54">µ</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 145pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Just(Just x)</p><p class="s22" style="padding-top: 3pt;padding-left: 64pt;text-indent: 0pt;text-align: left;">µ</p><p style="padding-top: 4pt;text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p class="s21" style="padding-left: 61pt;text-indent: 0pt;line-height: 10pt;text-align: left;"> </p><p class="s33" style="padding-left: 45pt;text-indent: 0pt;line-height: 13pt;text-align: left;">¸<span class="s34">/ </span><span class="p">Just x</span></p><p style="padding-top: 3pt;text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 47pt;text-indent: 0pt;text-align: justify;">These diagrams illustrate how the <span class="s6">Maybe </span>monad satisfies the monad laws, en- suring that sequences of operations within this monad are well-behaved.</p><p style="padding-top: 2pt;text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3.1.5"><h3 style="padding-left: 82pt;text-indent: -34pt;text-align: left;">Summary</h3><p style="padding-top: 6pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">Monads provide a robust framework for structuring computations, particularly in the presence of effects like failure, state, or non-determinism [4]. In Haskell, monads encapsulate these patterns, enabling concise and powerful expressions of complex operations. The mathematical structure of monads ensures that these operations are consistent and associative, making them a fundamental tool in both category theory and functional programming.</p><p style="padding-top: 14pt;text-indent: 0pt;text-align: left;"><br/></p></li></ol></li></ol></li><li data-list-text="4"><h1 style="padding-left: 71pt;text-indent: -24pt;text-align: left;">Conclusion</h1></li></ol><p style="padding-top: 8pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">In this paper, we have provided an overview of few key concepts in category theory with a focus on their application within the Haskell programming lan- guage. We began by introducing the fundamental structures of category theory, including categories, functors, and natural transformations, which serve as the building blocks for abstract reasoning in mathematics and computer science. These basic concepts are essential for understanding how various mathematical structures relate to one another in a coherent and structured manner.</p><p style="padding-left: 47pt;text-indent: 14pt;text-align: justify;">We then delved a bit into the advanced concept of monads, which have be- come a cornerstone in functional programming, particularly in Haskell. Monads encapsulate patterns of computation, allowing for the chaining of operations while managing side effects in a purely functional way. By exploring the math- ematical underpinnings of monads, we highlighted their significance in both theoretical and practical contexts, demonstrating how they enable complex be- haviors to be expressed in a clean and modular fashion.</p><p style="padding-left: 47pt;text-indent: 14pt;text-align: justify;">This exploration has illustrated how category theory provides a powerful and unifying language for abstract reasoning, which can be applied across diverse areas of mathematics and computer science. For Haskell programmers, under- standing these concepts can lead to more robust and maintainable code, as well as deeper insights into the nature of computation.</p><p style="padding-left: 47pt;text-indent: 14pt;text-align: justify;">While this paper has covered foundational and advanced topics, it is by no means exhaustive. Category theory is a vast and intricate field, and there remain many more concepts and applications to explore. Future work could involve a deeper investigation into other categorical structures, such as comonads, and their implications in functional programming. Additionally, more applied ex- amples could further bridge the gap between theory and practice, making these abstract ideas more accessible and useful to a broader audience.</p><p style="padding-left: 47pt;text-indent: 14pt;text-align: justify;">In conclusion, category theory, and particularly the concept of monads, of- fers a rich framework for understanding and managing complexity in functional programming. As the Haskell community continues to grow and evolve, the insights provided by category theory will remain a crucial part of the language’s theoretical foundation and practical utility.</p><p style="padding-top: 4pt;text-indent: 0pt;text-align: left;"><br/></p><h1 style="padding-left: 47pt;text-indent: 0pt;text-align: left;">References</h1><ol id="l40"><li data-list-text="[1]"><p style="padding-top: 8pt;padding-left: 63pt;text-indent: -15pt;text-align: left;">Steve Awodey. <i>Category theory</i>. Oxford University Press, 2010.</p></li><li data-list-text="[2]"><p style="padding-top: 8pt;padding-left: 63pt;text-indent: -15pt;text-align: justify;">Paul Hudak, John Hughes, Simon Peyton Jones, and Philip Wadler. A history of haskell: being lazy with class. Technical Report Haskell Report, ACM SIGPLAN Notices, 2007.</p></li><li data-list-text="[3]"><p style="padding-top: 7pt;padding-left: 63pt;text-indent: -15pt;text-align: justify;">Saunders Mac Lane. <i>Categories for the Working Mathematician</i>. Springer, 1998.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="[4]"><p style="padding-left: 63pt;text-indent: -15pt;text-align: justify;">Philip Wadler. The essence of functional programming. <i>Proceedings of the 19th ACM SIGPLAN-SIGACT symposium on Principles of programming languages</i>, pages 1–14, 1992.</p></li></ol></body></html>
